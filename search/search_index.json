{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"\u5927\u5f00\u7684\u7b14\u8bb0\u672c","text":"<p>\u4e1a\u7cbe\u4e8e\u52e4\uff0c\u8352\u4e8e\u5b09\uff1b\u884c\u6210\u4e8e\u601d\uff0c\u6bc1\u4e8e\u968f\u3002</p> <p>\u544a\u8bc9\u81ea\u5df1</p> <p>     \u6211\u8981\u4e00\u6b65\u4e00\u6b65\u5f80\u4e0a\u722c          \u5728\u6700\u9ad8\u70b9\u4e58\u7740\u53f6\u7247\u5f80\u524d\u98de       \u2014\u2014\u300a\u8717\u725b\u300b\u5468\u6770\u4f26 </p> <p> </p>"},{"location":"%E5%88%B7%E9%A2%98/BFS/PAT%20A1091_Acute%20Stroke/","title":"PAT A1091 Acute Stroke","text":"<p>\u601d\u8def\uff1a\u672c\u9898\u4e3a\u4e09\u7ef4BFS\uff0c\u672c\u8d28\u4e0a\u548c\u4e8c\u7ef4BFS\u76f8\u540c\uff0c\u4e0d\u8fc7\u4ece\u4e0a\u4e0b\u5de6\u53f34\u79cd\u65b9\u5411\u62d3\u5c55\u4e3a\u4e0a\u4e0b\u5de6\u53f3\u524d\u540e6\u79cd\u65b9\u5411\u3002\u4e00\u4e2a\u8fde\u901a\u7a7a\u95f4\u5373\u4e3a\u4e00\u4e2a\u6838\uff0c\u8fbe\u5230\u9608\u503cT\u7684\u6838\u53ef\u4ee5\u7b97\u8fdb\u603b\u4f53\u79ef\u4e2d\u3002\u6ce8\u610fBFS\u4e2d\u6bcf\u6b21\u8c03\u7528BFS\u76f8\u5f53\u4e8e\u8d70\u8fc7\u4e86\u4e00\u4e2a\u8fde\u901a\u533a\u57df\uff0c\u9700\u8981\u8bbe\u7f6evisit\u6570\u7ec4\u9632\u6b62\u91cd\u590d\u8bbf\u95ee\u5df2\u7ecf\u8bbf\u95ee\u7684\u5750\u6807\u3002</p> <pre><code>#include&lt;cstdio&gt;\n#include&lt;queue&gt;\nusing namespace std;\n\nint M, N, L, T, ans;\n\ntypedef struct {\n    int x, y, z;\n} Node;\n\nint dx[6] = {0, 0, 0, 0, 1, -1};\nint dy[6] = {0, 0, 1, -1, 0, 0};\nint dz[6] = {1, -1, 0, 0, 0, 0};\n\nint graph[1290][130][61];\nbool visit[1290][130][61];\n\nbool judge(int x, int y, int z) {\n    if(x &lt; 0 || x &gt;= M || y &lt; 0 || y &gt;= N || z &lt; 0 || z &gt;= L) {\n        return false;\n    }\n    if(graph[x][y][z] == 0 || visit[x][y][z] == true) {\n        return false;\n    }\n    return true;\n}\n\nint BFS(int x, int y, int z) {\n    queue&lt;Node&gt; q;\n    Node temp;\n    temp.x = x;\n    temp.y = y;\n    temp.z = z;\n    q.push(temp);\n    visit[x][y][z] = true;\n    int res = 0;\n    while(!q.empty()) {\n        Node node = q.front();\n        q.pop();\n        res++;\n        for(int i = 0; i &lt; 6; i++) {\n            int nx = node.x + dx[i];\n            int ny = node.y + dy[i];\n            int nz = node.z + dz[i];\n            if(judge(nx, ny, nz)) {\n                temp.x = nx;\n                temp.y = ny;\n                temp.z = nz;\n                q.push(temp);\n                visit[nx][ny][nz] = true;\n            }\n        }\n    }\n    if(res &lt; T) return 0;\n    return res;\n}\n\nint main() {\n    scanf(\"%d %d %d %d\", &amp;M, &amp;N, &amp;L, &amp;T);\n    for(int k = 0; k &lt; L; k++) \n        for(int i = 0; i &lt; M; i++) \n            for(int j = 0; j &lt; N; j++) \n                scanf(\"%d\", &amp;graph[i][j][k]);\n    for(int z = 0; z &lt; L; z++) \n        for(int x = 0; x &lt; M; x++)\n            for(int y = 0; y &lt; N; y++)\n                if(graph[x][y][z] == 1 &amp;&amp; visit[x][y][z] == false)\n                    ans += BFS(x, y, z);\n    printf(\"%d\", ans);\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/DFS/PAT%20A1103_Integer%20Factorization/","title":"PAT A1103 Integer Factorization","text":"<p>\u601d\u8def\uff1a\u5148\u5bf9\u5b58\u50a8\u56e0\u5b50\u7684fac\u6570\u7ec4\u8fdb\u884c\u9884\u5904\u7406\uff0c\u6bd4\u5982\u5047\u8bbe p = 2\uff0c\u53ef\u5f97 fac[0] = 0, fac[1] = 1, fac[2] = 4 \u7b49\u3002\u76f4\u63a5\u9884\u5904\u7406\u81f3fac[i] &gt;= n\uff0c\u518d\u901a\u8fc7DFS\u8fdb\u884c\u641c\u7d22\u6c42\u51fa\u6700\u4f18\u89e3\u3002  <pre><code>#include&lt;cstdio&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; fac, ans, res;\n\nint n, k, p, maxFacSum = 0;\n\nint power(int x) {\n    int num = 1;\n    for(int i = 0; i &lt; p; i++)\n        num *= x;\n    return num;\n}\n\nvoid DFS(int idx, int numK, int sum, int facSum) {\n    if(sum == n &amp;&amp; numK == k) {\n        if(facSum &gt; maxFacSum) {\n            ans = res;\n            maxFacSum = facSum;\n        }\n        return;\n    }\n    if(sum &gt; n || numK &gt; k) return;\n    if(idx &gt;= 1) {\n        res.push_back(idx);\n        DFS(idx, numK + 1, sum + fac[idx], facSum + idx);\n        res.pop_back();\n        DFS(idx - 1, numK, sum, facSum);\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &amp;n, &amp;k, &amp;p);\n    int facP = 0, cnt = 0;\n    while(facP &lt;= n) {\n        fac.push_back(facP);\n        facP = power(++cnt);\n    }\n    DFS(fac.size() - 1, 0, 0, 0);\n    if(maxFacSum == 0)\n        printf(\"Impossible\");\n    else {\n        printf(\"%d = %d^%d\", n, ans[0], p);\n        for(int i = 1; i &lt; ans.size(); i++)\n            printf(\" + %d^%d\", ans[i], p);\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/PAT%20A1010_Radix/","title":"PAT A1010 Radix","text":"<p>\u601d\u8def\uff1a\u672c\u9898\u4f7f\u7528\u4e8c\u5206\u6cd5\u6765\u67e5\u627e\u7b54\u6848\u8fdb\u5236\u6570\u5b57\uff0c\u5148\u5c06\u5df2\u7ecf\u786e\u5b9a\u8fdb\u5236\u7684\u8f93\u5165 N1 \u8f6c\u5316\u4e3a\u5341\u8fdb\u5236\uff0c\u518d\u5c06\u5f85\u786e\u5b9a\u8fdb\u5236\u7684\u8f93\u5165 N2 \u4e8c\u5206\u67e5\u627e\u8f6c\u5316\u4e3a\u5341\u8fdb\u5236\u3002\u9700\u8981\u6ce8\u610f\u4f7f\u7528 long long \u7c7b\u578b\u6765\u907f\u514d\u6ea2\u51fa\u95ee\u9898\u3002\u6700\u91cd\u8981\u7684\u662f\u786e\u5b9a\u4e0a\u754c\u548c\u4e0b\u754c\uff0c\u4e0b\u754c\u4e3a N2 \u7684\u5404\u4f4d\u4e2d\u6700\u5927\u503c + 1\uff0c\u4e0a\u754c\u4e3a N1 \u7684\u5341\u8fdb\u5236\u503c\u548c\u4e0b\u754c\u4e8c\u8005\u4e2d\u53d6\u6700\u5927\u503c\u3002\u6ce8\u610f\u4e24\u4e2a\u8f93\u5165\u6570\u636e\u76f8\u540c\u65f6\uff0c\u8f93\u5165\u7ed9\u51fa\u7684 radix \u5373\u4e3a\u76ee\u6807\u8fdb\u5236\u3002 </p> <pre><code>#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nstring N1, N2;\nint tag, radix;\n\nint chToInt(char ch) {\n    return isalpha(ch) ? (ch - 'a' + 10) : (ch - '0');\n}\n\nint calLowBound(string s) {\n    int res = 0;\n    for(int i = 0; i &lt; s.size(); i++) {\n        res = max(res, chToInt(s[i]));\n    }\n    return res + 1;\n}\n\nlong long calDecVal(string s, long long a) {\n    if(a == 10) return (long long)atoi(s.c_str());\n    long long res = 0, k = 1;\n    for(int i = s.size() - 1; i &gt;= 0; i--) {\n        res += k * chToInt(s[i]);\n        k *= a;\n    }\n    return res;\n}\n\nlong long calRadix(string s, long long x, long long L, long long R) {\n    long long mid, temp;\n    // \u95ed\u533a\u95f4\u4e8c\u5206\n    while(L &lt;= R) {\n        mid = (L + R) / 2;\n        temp = calDecVal(s, mid);\n        if(temp == x) return mid;\n        else if(temp &gt; x || temp &lt; 0) R = mid - 1;\n        else L = mid + 1;\n    }\n    return -1;\n}\n\n\n\nint main() {\n    cin &gt;&gt; N1 &gt;&gt; N2 &gt;&gt; tag &gt;&gt; radix;\n    if(N1 == N2) {\n        cout &lt;&lt; radix;\n        return 0;\n    }\n    if(tag == 2) swap(N1, N2);\n    long long N1_DecVal = calDecVal(N1, radix);\n    long long L = calLowBound(N2);\n    long long R = max(N1_DecVal, L);\n    long long ans = calRadix(N2, N1_DecVal, L, R);\n    if(ans != -1) cout &lt;&lt; ans;\n    else cout &lt;&lt; \"Impossible\";\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/0-1%E8%83%8C%E5%8C%85/PAT%20A1068_Find%20More%20Coins/","title":"PAT A1068 Find More Coins","text":"<p>\u601d\u8def\uff1a\u672c\u9898\u4e3a0-1\u80cc\u5305\u7684\u53d8\u5f62\u7248\uff0c\u6c420-1\u80cc\u5305\u7684\u6700\u5c0f\u5b57\u5178\u5e8f\u95ee\u9898\u3002\u5176\u4e2d dp[i][j] \u4ee3\u8868\u4ece 1 ~ i \u53f7\u786c\u5e01\u4e2d\u9009\u62e9\uff0c\u5728\u6700\u5927\u652f\u4ed8\u989d\u5ea6\u4e3a j \u7684\u6761\u4ef6\u4e0b\u80fd\u652f\u4ed8\u7684\u6700\u5927\u91d1\u989d\u3002\u7531\u4e8e\u672c\u9898\u4e2d\u8d1f\u91cd\u548c\u4ef7\u503c\u4e3a\u540c\u4e00\u6570\u636e\uff0c\u7531\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b dp[i][j] = max{dp[i-1][j], dp[i-1][j - coins[i]] + coins[i]} \u77e5\u5176\u6700\u5927\u91d1\u989d\u4e0d\u4f1a\u8d85\u51fa\u6700\u5927\u989d\u5ea6\u3002\u6240\u4ee5\u5224\u65ad\u662f\u5426\u6709\u89e3\u7684\u6761\u4ef6\u4e3a dp[n][m] == m\uff0c\u5176\u4e2d n \u4e3a\u786c\u5e01\u603b\u6570\uff0cm \u4e3a\u76ee\u6807\u652f\u4ed8\u989d\u5ea6\u3002</p> <p>\u6700\u5c0f\u5b57\u5178\u5e8f\uff1a\u5c06\u786c\u5e01\u4ece\u5927\u5230\u5c0f\u6392\u5e8f\uff0c\u5148\u8003\u8651\u5927\u786c\u5e01\uff0c\u904d\u5386\u5230\u5c0f\u786c\u5e01\u65f6\u53ef\u4ee5\u8fdb\u884c\u62c6\u5206\uff0c\u5373 dp[i][j] &lt;= dp[i-1][j-coins[i]] + coins[i] \u65f6\u8fdb\u884c\u7684\u62c6\u5206\u3002\u6c42\u51fa\u8def\u5f84\u65f6\uff0c\u5bf9\u4e8e i \u53f7\u786c\u5e01\uff0c\u5224\u65ad dp[i][j] == dp[i-1][j-coins[i]] + coins[i] \u6210\u7acb\u5373\u9700\u8981\u9009\u62e9\u8be5\u786c\u5e01\u3002</p> <p>\u7a7a\u95f4\u4f18\u5316\uff1a\u5c06 dp \u4f18\u5316\u6210\u4e00\u7ef4\u6570\u7ec4\uff0c\u6839\u636e\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u9700\u8981\u6539\u53d8 v \u7684\u904d\u5386\u65b9\u5411\uff0c\u53e6\u9700\u8981\u8bbe\u7f6e choose \u548c flag \u6570\u7ec4\u6765\u5224\u65ad\uff0c\u4ee3\u7801\u53ef\u89c1\u300a\u7b97\u6cd5\u7b14\u8bb0\u300b\u3002</p> <pre><code>// \u4e8c\u7ef4\u6570\u7ec4\u7248\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nconst int MAXN = 10005, MAXM = 105;\nint coins[MAXN], dp[MAXN][MAXM];\nint n, m;\nvector&lt;int&gt; ans;\n\nbool cmp(int a, int b) {\n    return a &gt; b;\n}\n\nint main() {\n    cin &gt;&gt; n &gt;&gt; m;\n    for(int i = 1; i &lt;= n; i++)\n        cin &gt;&gt; coins[i];\n    sort(coins + 1, coins + n + 1, cmp);\n    // dp\u8fc7\u7a0b\n    for(int i = 1; i &lt;= n; i++) {\n        for(int v = coins[i]; v &lt;= m; v++) {\n            dp[i][v] = max(dp[i-1][v], dp[i-1][v-coins[i]] + coins[i]);\n        }\n    }\n    // \u8f93\u51fa\u8def\u5f84\n    if(dp[n][m] != m) cout &lt;&lt; \"No Solution\";\n    else {\n        int j = m;\n        for(int i = n; i &gt;= 1; i--) {\n            if(j &gt;= coins[i] &amp;&amp; dp[i][j] == dp[i - 1][j - coins[i]] + coins[i]) {\n                ans.push_back(coins[i]);\n                j -= coins[i];\n            }\n        }\n        for(int i = 0; i &lt; ans.size(); i++) {\n            cout &lt;&lt; ans[i];\n            if(i &lt; ans.size() - 1) cout &lt;&lt; \" \";\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/LeetCode%205.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","title":"LeetCode 5.\u6700\u957f\u56de\u6587\u5b50\u4e32","text":"<p>\u601d\u8def\uff1a\u672c\u9898\u4e0e PAT A1040 \u76f8\u4f3c\uff0c\u4e0e LeetCode 516 \u6700\u5927\u7684\u533a\u522b\u5728\u4e8e\u672c\u9898\u6c42\u7684\u662f\u5b50\u4e32\u800c\u975e\u5b50\u5e8f\u5217\uff0c\u5b50\u5e8f\u5217\u53ef\u4ee5\u8fdb\u884c\u5220\u51cf\u3002</p>"},{"location":"%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/LeetCode%20516.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/","title":"LeetCode 516.\u6700\u957f\u56de\u6587\u5b50\u5e8f\u5217","text":"<p>\u601d\u8def\uff1a\u56de\u6587\u5b50\u5e8f\u5217\u548cLCS\u7684\u505a\u6cd5\u6bd4\u8f83\u76f8\u4f3c\uff0cs[i] = s[j] \u65f6\uff0c\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u4e3a dp[i][j] = dp[i + 1][j - 1] + 2\u3002 \u5426\u5219\u4e3a dp[i][j] = max{dp[i + 1][j], dp[i][j - 1]} \u5373\u4e0d\u9009 s[i] \u6216\u8005\u4e0d\u9009 s[j]\u3002</p> <p>dp[i][j] \u4ee3\u8868\u4ece s[i] \u5230 s[j] \u7684\u56de\u6587\u5b50\u5e8f\u5217\u6700\u5927\u957f\u5ea6\uff0c\u53ef\u77e5 i \u7684\u8f6c\u79fb\u987a\u5e8f\u4ece n - 1 \u5230 0\uff0cj \u7684\u8f6c\u79fb\u987a\u5e8f\u4ece i + 1 \u5230 n - 1\u3002</p> <p>\u672c\u9898\u53ef\u4ee5\u8fdb\u884c\u7a7a\u95f4\u4f18\u5316\uff0c\u4ee3\u7801\u5982\u4e0b\u3002</p> <pre><code>class Solution {\npublic:\n    int longestPalindromeSubseq(string s) {\n        int n = s.size();\n        vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0));\n        for(int i = n - 1; i &gt;= 0; i--) {\n            dp[i][i] = 1;\n            for(int j = i + 1; j &lt; n; j++) {\n                if(s[i] == s[j])\n                    dp[i][j] = dp[i + 1][j - 1] + 2;\n                else\n                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);\n            }\n        }\n        return dp[0][n - 1];\n    }\n};\n\n//\u7a7a\u95f4\u4f18\u5316\nclass Solution {\npublic:\n    int longestPalindromeSubseq(string s) {\n        int n = s.size();\n        vector&lt;int&gt; dp(n, 0);\n        for(int i = n - 1; i &gt;= 0; i--) {\n            dp[i] = 1;\n            int pre = 0;\n            for(int j = i + 1; j &lt; n; j++) {\n                int temp = dp[j];\n                if(s[i] == s[j])\n                    dp[j] = pre + 2;\n                else\n                    dp[j] = max(dp[j], dp[j - 1]);\n                pre = temp;\n            }\n        }\n        return dp[n - 1];\n    }\n};\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%8C%BA%E9%97%B4DP/PAT%20A1040_Longest%20Symmetric%20String/","title":"PAT A1040 Longest Symmetric String","text":"<p>\u601d\u8def\uff1a\u672c\u9898\u7684\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u4e3a dp[i][j] = dp[i + 1][j - 1] &amp;&amp; s[i] = s[j]\uff0c\u6ce8\u610f\u5b50\u4e32\u957f\u5ea6\u4e3a2\u65f6\u7279\u6b8a\u5904\u7406\u3002</p> <p>\u672c\u9898\u53ef\u4ee5\u8fdb\u884c\u7a7a\u95f4\u4f18\u5316\uff0c\u4ee3\u7801\u5982\u4e0b\u3002 <pre><code>#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconst int MAXN = 1005;\n\nbool dp[MAXN][MAXN];\n\nint main() {\n    string s;\n    getline(cin, s);\n    int n = s.size();\n    int ans = 1;\n    for(int i = n - 1; i &gt;= 0; i--) {\n        dp[i][i] = true;\n        for(int j = i + 1; j &lt; n; j++) {\n            dp[i][j] = (s[i] == s[j]) &amp;&amp; (j - i &lt; 2 || dp[i + 1][j - 1]);\n            if(dp[i][j] &amp;&amp; j - i + 1 &gt; ans) ans = j - i + 1; \n        }\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n\n// \u7a7a\u95f4\u4f18\u5316\n#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconst int MAXN = 1005;\n\nbool dp[MAXN];\n\nint main() {\n    string s;\n    getline(cin, s);\n    int n = s.size();\n    int ans = 1;\n    for(int i = n - 1; i &gt;= 0; i--) {\n        bool pre = false;\n        dp[i] = true;\n        for(int j = i + 1; j &lt; n; j++) {\n            bool temp = dp[j];\n            dp[j] = (s[i] == s[j]) &amp;&amp; (j - i &lt; 2 || pre);\n            if(dp[j] &amp;&amp; j - i + 1 &gt; ans) ans = j - i + 1; \n            pre = temp;\n        }\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/PAT%20A1007_Maximum%20Subsequence%20Sum/","title":"PAT A1007 Maximum Subsequence Sum","text":"<p>\u601d\u8def\uff1a\u5229\u7528\u4e00\u7ef4dp\u6570\u7ec4\uff0cdp[i]\u4ee3\u8868\u4ee5a[i]\u4e3a\u7ed3\u5c3e\u7684\u5b50\u5e8f\u5217\u7684\u6700\u5927\u503c\uff0c\u5e76\u4e14\u4f7f\u7528s[i]\u8bb0\u5f55\u5b50\u5e8f\u5217\u7b2c\u4e00\u4e2a\u503c\u7684\u4e0b\u6807\u3002 \u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u4e3a dp[i] = max(dp[i-1] + a[i], a[i]) <pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconst int MAXN = 10005;\n\nint dp[MAXN], a[MAXN], s[MAXN];\nint K;\n\nint main() {\n    scanf(\"%d\", &amp;K);\n    bool flag = false;\n    for(int i = 0; i &lt; K; i++) {\n        scanf(\"%d\", &amp;a[i]);\n        if(a[i] &gt;= 0) flag = true;\n    }\n    if(!flag) {\n        printf(\"0 %d %d\", a[0], a[K - 1]);\n        return 0;\n    }\n    dp[0] = a[0];\n    for(int i = 1; i &lt; K; i++) {\n        if(dp[i - 1] + a[i] &gt; a[i]) {\n            dp[i] = dp[i - 1] + a[i];\n            s[i] = s[i-1];\n        } else {\n            dp[i] = a[i];\n            s[i] = i;\n        }\n    }\n    int res = 0;\n    for(int i = 1; i &lt; K; i++)\n        if(dp[i] &gt; dp[res])\n            res = i;\n    printf(\"%d %d %d\", dp[res], a[s[res]], a[res]);\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/%E6%9C%80%E9%95%BF%E4%B8%8D%E4%B8%8B%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97LIS/PAT%20A1045_Favorite%20Color%20Stripe/","title":"PAT A1045 Favorite Color Stripe","text":"<p>\u601d\u8def\uff1a</p> <p>\u5148\u5c06\u559c\u6b22\u7684\u957f\u5ea6\u4e3a M \u7684\u989c\u8272\u5e8f\u5217\u6620\u5c04\u5230 0 ~ M-1\uff0c\u4e4b\u540e\u76f4\u63a5\u5c06\u4e0d\u559c\u6b22\u7684\u989c\u8272\u5e8f\u5217\u5220\u53bb\uff0c\u91cd\u65b0\u6574\u7406\u5f97\u5230\u6620\u5c04\u540e\u5b58\u7559\u7684\u989c\u8272\u5e8f\u5217a\u3002\u6b64\u65f6\u5b58\u7559\u7684\u5e8f\u5217\u4e00\u5b9a\u90fd\u662f\u559c\u6b22\u7684\u989c\u8272\u3002\u518d\u6309\u7167LIS\u7684\u6a21\u677f\uff0cdp[i]\u4ee3\u8868a[i]\u7ed3\u5c3e\u7684\u6700\u957f\u5e8f\u5217\uff0c\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u4e3adp[i] = max{dp[j]} + 1, 0 &lt; j &lt; i\uff0c\u4e14\u6ee1\u8db3a[j] &lt;= a[i]\u5373\u4e0d\u9012\u51cf\u3002</p> <pre><code>//LIS\n#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconst int MAXC = 210;\nconst int MAXN = 10010;\n\nint hashTable[MAXC], a[MAXN], dp[MAXN];\n\nint main() {\n    int numColor, M;\n    scanf(\"%d%d\", &amp;numColor, &amp;M);\n    fill(hashTable, hashTable + MAXC, -1);\n    int color;\n    for(int i = 0; i &lt; M; i++) {\n        scanf(\"%d\", &amp;color);\n        hashTable[color] = i;\n    }\n    int totalColor, num = 0;\n    scanf(\"%d\", &amp;totalColor);\n    for(int i = 0; i &lt; totalColor; i++) {\n        scanf(\"%d\", &amp;color);\n        if(hashTable[color] &gt;= 0) \n            a[num++] = hashTable[color];\n    }\n    int ans = -1;\n    for(int i = 0; i &lt; num; i++) {\n        dp[i] = 1;\n        for(int j = 0; j &lt; i; j++) \n            if(a[j] &lt;= a[i] &amp;&amp; dp[i] &lt; dp[j] + 1)\n                dp[i] = dp[j] + 1;\n        ans = max(ans, dp[i]);\n    }\n    printf(\"%d\", ans);\n    return 0;\n}\n\n//LCS\n#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int MAXC = 210;\nconst int MAXN = 10005;\n\nint A[MAXC], B[MAXN], dp[MAXC][MAXN];\n\nint main() {\n    int N, M;\n    scanf(\"%d%d\", &amp;N, &amp;M);\n    for(int i = 1; i &lt;= M; i++)\n        scanf(\"%d\", &amp;A[i]);\n    int L;\n    scanf(\"%d\", &amp;L);\n    for(int i = 1; i &lt;= L; i++)\n        scanf(\"%d\", &amp;B[i]);\n    for(int i = 1; i &lt;= M; i++) {\n        for(int j = 1; j &lt;= L; j++) {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            if(A[i] == B[j]) dp[i][j] += 1;\n        }\n    }\n    printf(\"%d\", dp[M][L]);\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97LCS/LeetCode%2072.%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/","title":"LeetCode 72.\u7f16\u8f91\u8ddd\u79bb","text":"<p>\u601d\u8def\uff1a\u4e00\u5171\u6709\u4e09\u79cd\u64cd\u4f5c\uff0c\u63d2\u5165\uff0c\u5220\u9664\u548c\u66ff\u6362\u3002\u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u4e3a\uff0c\u82e5 s[i] = t[j]\uff0cdp[i][j] = dp[i - 1][j - 1]\u3002d \u82e5 s[i] != t[j]\uff0cdp[i][j] = min{dp[i][j - 1]\uff08\u63d2\u5165\uff09, dp[i - 1][j]\uff08\u5220\u9664\uff09, dp[i - 1][j - 1]\uff08\u66ff\u6362\uff09} + 1\u3002</p> <p>\u7a7a\u95f4\u4f18\u5316\uff1a\u672c\u9898\u4f9d\u8d56\u7684\u72b6\u6001\u8f6c\u79fb\u53ef\u7528\u6eda\u52a8\u6570\u7ec4\u8fdb\u884c\u4f18\u5316\u6210\u4e24\u4e2a\u4e00\u7ef4\u6570\u7ec4\uff0c\u4e24\u4e2a\u4e00\u7ef4\u6570\u7ec4\u7684\u72b6\u6001\u8f6c\u79fb\u4ec5\u4f9d\u8d56\u4e8e\u5de6\uff0c\u4e0a\uff0c\u5de6\u4e0a\uff0c\u4e09\u4e2a\u65b9\u5411\uff0c\u5176\u4e2d\u5de6\u4e0a\u4f1a\u88ab\u5de6\u8986\u76d6\u3002 \u56e0\u6b64\u53ef\u4ee5\u8bbe\u7f6e\u4e34\u65f6\u53d8\u91cf\u6765\u4fdd\u5b58\u5de6\u4e0a\u7684\u72b6\u6001\uff0c\u4f18\u5316\u6210\u4e00\u7ef4\u6570\u7ec4\u3002 <pre><code>class Solution {\npublic:\n    int min(int a, int b, int c) {\n        if(a &lt; b) return a &gt; c ? c : a;\n        return b &gt; c ? c : b;\n    }\n\n    int minDistance(string word1, string word2) {\n        int m = word1.size(), n = word2.size();\n        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));\n        for(int j = 0; j &lt; n; j++) {\n            dp[0][j + 1] = j + 1;\n        }\n        for(int i = 0; i &lt; m; i++) {\n            dp[i + 1][0] = i + 1;\n            for(int j = 0; j &lt; n; j++) {\n                if(word1[i] == word2[j]) {\n                    dp[i + 1][j + 1] = dp[i][j];\n                } else {\n                    dp[i + 1][j + 1] = min(dp[i + 1][j], dp[i][j + 1], dp[i][j]) + 1;\n                }\n            }\n        }\n        return dp[m][n];\n    }\n};\n\n//\u7a7a\u95f4\u4f18\u5316\nclass Solution {\npublic:\n    int min(int a, int b, int c) {\n        if(a &lt; b) return a &gt; c ? c : a;\n        return b &gt; c ? c : b;\n    }\n\n    int minDistance(string word1, string word2) {\n        int m = word1.size(), n = word2.size();\n        vector&lt;int&gt; dp(n + 1, 0);\n        for(int j = 0; j &lt; n; j++) {\n            dp[j + 1] = j + 1;\n        }\n        int pre, temp;\n        for(int i = 0; i &lt; m; i++) {\n            pre = dp[0];\n            dp[0] += 1;\n            for(int j = 0; j &lt; n; j++) {\n                temp = dp[j + 1];\n                if(word1[i] == word2[j]) {\n                    dp[j + 1] = pre;\n                } else {\n                    dp[j + 1] = min(dp[j], temp, pre) + 1;\n                }\n                pre = temp;\n            }\n        }\n        return dp[n];\n    }\n};\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E7%BA%BF%E6%80%A7DP/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97LCS/PAT%20A1045_Favorite%20Color%20Stripe/","title":"PAT A1045 Favorite Color Stripe","text":"<p>\u601d\u8def\uff1a\u672c\u9898\u4e3a LCS \u6a21\u677f\u9898\u7684\u53d8\u5f62\u3002\u539f\u672c LCS \u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b\u4e2d\uff0c\u82e5 A[i] == B[j]\uff0c\u5219 dp[i][j] = dp[i - 1][j - 1] + 1\uff08\u53ef\u8bc1\u660e\uff09\u3002</p> <p>\u7531\u4e8e\u672c\u9898\u4e2d\u53ef\u4ee5\u4ea7\u751f\u91cd\u590d\u5143\u7d20\u5339\u914d\uff0c\u6b64\u65f6\u8f6c\u79fb\u65b9\u7a0b\u53d8\u4e3a dp[i][j] = max{dp[i - 1][j], dp[i][j - 1]} + 1\u3002</p> <p>\u8fb9\u754c\uff1adp[i][0] = dp[0][j] = 0 (0 &lt;= i &lt;= n, 0 &lt;= j &lt;= n)</p> <pre><code>//LCS\n#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int MAXC = 210;\nconst int MAXN = 10005;\n\nint A[MAXC], B[MAXN], dp[MAXC][MAXN];\n\nint main() {\n    int N, M;\n    scanf(\"%d%d\", &amp;N, &amp;M);\n    for(int i = 1; i &lt;= M; i++)\n        scanf(\"%d\", &amp;A[i]);\n    int L;\n    scanf(\"%d\", &amp;L);\n    for(int i = 1; i &lt;= L; i++)\n        scanf(\"%d\", &amp;B[i]);\n    for(int i = 1; i &lt;= M; i++) {\n        for(int j = 1; j &lt;= L; j++) {\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]);\n            if(A[i] == B[j]) dp[i][j] += 1;\n        }\n    }\n    printf(\"%d\", dp[M][L]);\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E5%9B%BE/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/PAT%20A1013_Battle%20Over%20Cities/","title":"PAT A1013 Battle Over Cities","text":"<p>\u601d\u8def\uff1a\u672c\u9898\u53ef\u4ee5\u7528DFS\u548c\u5e76\u67e5\u96c6\u4e24\u79cd\u505a\u6cd5\u3002</p> <p>DFS\uff1a\u5bf9\u56fe\u8fdb\u884cDFS\u904d\u5386\uff0c\u5f97\u5230\u82e5\u5e72\u4e2a\u8fde\u901a\u5206\u91cf\uff0c\u9700\u8981\u8865\u5145\u7684\u9053\u8def\u6570\u91cf\u5373\u4e3a\u8fde\u901a\u5206\u91cf-1</p> <p>\u5e76\u67e5\u96c6\uff1a\u5bf9\u88ab\u5220\u9664\u4e4b\u5916\u7684\u70b9\u8fdb\u884cUnion\uff0c\u6700\u540e\u67e5\u8be2\u96c6\u5408\u4e2a\u6570\uff0c\u7b49\u540c\u4e8e\u8fde\u901a\u5206\u91cf\u6570</p> <pre><code>//DFS\n#include&lt;cstdio&gt;\n#include&lt;vector&gt;\n#include&lt;cstring&gt;\nusing namespace std;\n\nconst int maxn = 1005;\n\nvector&lt;int&gt; G[maxn];\nbool visit[maxn];\nint N, M, K;\nint delVertex;\n\nvoid DFS(int v) {\n    if(v == delVertex) return;\n    visit[v] = true;\n    for(int i = 0; i &lt; G[v].size(); i++) \n        if(!visit[G[v][i]]) DFS(G[v][i]);\n}\n\nint main() {\n    scanf(\"%d %d %d\", &amp;N, &amp;M, &amp;K);\n    int v1, v2;\n    for(int i = 0; i &lt; M; i++) {\n        scanf(\"%d %d\", &amp;v1, &amp;v2);\n        G[v1].push_back(v2);\n        G[v2].push_back(v1);\n    }\n    int block;\n    for(int q = 0; q &lt; K; q++) {\n        scanf(\"%d\", &amp;delVertex);\n        memset(visit, false, sizeof(visit));\n        block = 0;\n        for(int i = 1; i &lt;= N; i++) {\n            if(i != delVertex &amp;&amp; !visit[i]) {\n                DFS(i);\n                block++;\n            }\n        }\n        printf(\"%d\\n\", block - 1);\n    }\n    return 0;\n}\n</code></pre> <pre><code>//\u5e76\u67e5\u96c6\n#include&lt;cstdio&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nconst int maxn = 1005;\n\nvector&lt;int&gt; G[maxn];\nbool visit[maxn];\nint father[maxn];\nint N, M, K;\nint delVertex;\n\nint findFather(int x) {\n    int temp = x;\n    while(x != father[x])\n        x = father[x];\n    int a;\n    while(temp != father[temp]) {\n        a = temp;\n        temp = father[temp];\n        father[a] = x;\n    }\n    return x;\n}\n\nvoid Union(int a, int b) {\n    int fa = findFather(a);\n    int fb = findFather(b);\n    if(fa != fb) father[fa] = fb;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &amp;N, &amp;M, &amp;K);\n    int v1, v2;\n    for(int i = 0; i &lt; M; i++) {\n        scanf(\"%d %d\", &amp;v1, &amp;v2);\n        G[v1].push_back(v2);\n        G[v2].push_back(v1);\n    }\n    int block;\n    for(int q = 0; q &lt; K; q++) {\n        scanf(\"%d\", &amp;delVertex);\n        for(int i = 1; i &lt;= N; i++) {\n            father[i] = i;\n            visit[i] = false;\n        }\n        for(int i = 1; i &lt;= N; i++) {\n            for(int j = 0; j &lt; G[i].size(); j++) {\n                v1 = i, v2 = G[i][j];\n                if(v1 == delVertex || v2 == delVertex)\n                    continue;\n                Union(v1, v2);\n            }\n        }\n        block = 0;\n        for(int i = 1; i &lt;= N; i++) {\n            if(i == delVertex) continue;\n            int f = findFather(i);\n            if(!visit[f]) {\n                block++;\n                visit[f] = true;\n            }\n        }\n        printf(\"%d\\n\", block - 1);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E5%9B%BE/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/PAT%20A1021_Deepest%20Root/","title":"PAT A1021 Deepest Root","text":"<p>\u601d\u8def\uff1a\u9996\u5148\u5229\u7528\u5e76\u67e5\u96c6\u786e\u5b9a\u662f\u5426\u80fd\u591f\u6784\u6210\u4e00\u68f5\u6811\uff0c\u5373\u6574\u4e2a\u56fe\u53ea\u6709\u4e00\u4e2afather\u3002\u7531\u4e8e\u56fe\u8fde\u901a\u4e14\u6709n\u4e2a\u7ed3\u70b9\uff0c\u8fb9\u6570\u4e3an-1\uff0c\u53ef\u77e5\u4e00\u5b9a\u80fd\u6784\u6210\u4e00\u68f5\u6811\u3002\u9009\u53d6\u4efb\u610f\u7ed3\u70b9\u8fdb\u884cDFS\u5f97\u5230\u6700\u5927\u9ad8\u5ea6\u7684\u7aef\u70b9\uff0c\u4e00\u5b9a\u4e3a\u5019\u9009\u7684Deepest Root\u7ed3\u70b9\uff0c\u79f0\u4f5c\u96c6\u5408A\u3002\u518d\u6b21\u4ece\u8fd9\u4e9b\u96c6\u5408A\u7684\u67d0\u4e00\u4e2a\u7ed3\u70b9\u51fa\u53d1\uff0c\u5f97\u5230\u6700\u5927\u9ad8\u5ea6\u7684\u7aef\u70b9\u96c6\u5408\u79f0\u4f5c\u96c6\u5408B\u3002\u53ef\u8bc1\uff08\u8be6\u89c1\u7b97\u6cd5\u7b14\u8bb0\uff09A\u4e0eB\u7684\u5e76\u96c6\uff08\u6ce8\u610f\u53bb\u91cd\uff09\u5373\u4e3a\u6240\u6c42\u7684Deepest Root\u7ed3\u70b9\u96c6\u5408\u3002 <pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nconst int maxn =10005;\n\nvector&lt;int&gt; G[maxn];\nint father[maxn];\nint isRoot[maxn];\nint n, maxHeight = 0;\nvector&lt;int&gt; ans, res;\n\nvoid init() {\n    for(int i = 1; i &lt;= n; i++)\n        father[i] = i;\n}\n\nint findFather(int x) {\n    int temp = x;\n    while(x != father[x]) \n        x = father[x];\n    int a;\n    while(temp != father[temp]) {\n        a = temp;\n        temp = father[temp];\n        father[a] = x;\n    }\n    return x;\n}\n\nvoid Union(int a, int b) {\n    int fa = findFather(a);\n    int fb = findFather(b);\n    if(fa != fb) father[fa] = fb;\n}\n\nint blockNum() {\n    int block = 0;\n    for(int i = 1; i &lt;= n; i++) \n        if(findFather(i) == i)\n            block++;\n    return block;\n}\n\nvoid DFS(int idx, int height, int pre) {\n    if(height &gt; maxHeight) {\n        maxHeight = height;\n        res.clear();\n        res.push_back(idx);\n    } else if(height == maxHeight)\n        res.push_back(idx);\n    for(int i = 0; i &lt; G[idx].size(); i++) {\n        if(G[idx][i] == pre) continue;\n        DFS(G[idx][i], height + 1, idx);\n    }\n}\n\nint main() {\n    scanf(\"%d\", &amp;n);\n    init();\n    int v1, v2;\n    for(int i = 0; i &lt; n - 1; i++) {\n        scanf(\"%d %d\", &amp;v1, &amp;v2);\n        G[v1].push_back(v2);\n        G[v2].push_back(v1);\n        Union(v1, v2);\n    }\n    int block = blockNum();\n    if(block == 1) {\n        DFS(1, 1, -1);\n        ans = res;\n        DFS(ans[0], 1, -1);\n        for(int i = 0; i &lt; res.size(); i++)\n            ans.push_back(res[i]);\n        sort(ans.begin(), ans.end());\n        printf(\"%d\\n\", ans[0]);\n        for(int i = 1; i &lt; ans.size(); i++)\n            if(ans[i] != ans[i - 1])\n                printf(\"%d\\n\", ans[i]);\n    } else {\n        printf(\"Error: %d components\\n\", block);\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E5%9B%BE/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/PAT%20A1034_Head%20of%20a%20Gang/","title":"PAT A1034 Head of a Gang","text":"<p>\u601d\u8def\uff1a\u901a\u8fc7\u90bb\u63a5\u77e9\u9635\u6784\u5efa\u5e2e\u6d3e\u56fe\uff0c\u901a\u8fc7DFS\u786e\u5b9a\u4e0d\u540c\u7684\u8fde\u901a\u5206\u91cf\u6765\u786e\u5b9a\u5e2e\u6d3e\u4e2a\u6570\u4ee5\u53ca\u4eba\u6570\u3002\u6ce8\u610f\u7ed9\u51fa\u7684\u56fe\u7ed3\u6784\u4e3a\u65e0\u5411\u56fe\uff0c\u4e3a\u7ed3\u70b9\u6dfb\u52a0\u5b8c\u6743\u91cd\u4e4b\u540e\uff0c\u7531\u6700\u5927\u6743\u91cd\u786e\u5b9a\u5e2e\u6d3e\u7262\u5927\u3002\u6574\u4e2a\u5e2e\u6d3e\u7684\u9608\u503c\u7531\u8fb9\u6743\u786e\u5b9a\uff0c\u5373\u6bcf\u6761\u8fb9\u53ea\u4f7f\u7528\u4e00\u6b21\uff0c\u4f7f\u7528\u540e\u5c06\u8fb9\u6743\u7f6e0\uff0c\u9632\u6b62\u91cd\u590d\u4f7f\u7528\u8fb9\u3002 \u6ce8\u610f\u9898\u76ee\u7ed9\u51fa\u6700\u5927\u7684n\u4e3a1000\uff0c\u4f46\u8003\u8651\u5230\u901a\u8bdd\u662f\u53cc\u65b9\u7684\uff0c\u56e0\u6b64maxn\u5e94\u8be5\u5927\u4e8e2000\u3002 <pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;string&gt;\n#include&lt;map&gt;\nusing namespace std;\n\nconst int maxn = 2010;\n\nmap&lt;string, int&gt; Str2Int;\nmap&lt;int, string&gt; Int2Str;\nmap&lt;string, int&gt; Gang;\nbool visit[maxn];\nint G[maxn][maxn], weight[maxn];\nint N, K, num;\n\nint transform(string s) {\n    if(Str2Int.find(s) != Str2Int.end())\n        return Str2Int[s];\n    Str2Int[s] = ++num;\n    Int2Str[num] = s;\n    return num;\n} \n\nvoid DFS(int nowVisit, int&amp; head, int&amp; numMember, int&amp; totalWeight) {\n    numMember++;\n    visit[nowVisit] = true;\n    if(weight[nowVisit] &gt; weight[head])\n        head = nowVisit;\n    for(int i = 1; i &lt;= num; i++)\n        if(G[nowVisit][i] &gt; 0) {\n            totalWeight += G[nowVisit][i];\n            G[nowVisit][i] = G[i][nowVisit] = 0;\n            if(!visit[i]) DFS(i, head, numMember, totalWeight);\n        }\n}\n\nint main() {\n    cin &gt;&gt; N &gt;&gt; K;\n    string s1, s2;\n    int w;\n    for(int i = 0; i &lt; N; i++) {\n        cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; w;\n        int id1 = transform(s1);\n        int id2 = transform(s2);\n        G[id1][id2] += w;\n        G[id2][id1] += w;\n        weight[id1] += w;\n        weight[id2] += w;\n    }\n    int head, numMember, totalWeight;\n    for(int i = 1; i &lt;= num; i++) \n        if(!visit[i]) {\n            head = i, numMember = 0, totalWeight = 0; \n            DFS(i, head, numMember, totalWeight);\n            if(numMember &gt; 2 &amp;&amp; totalWeight &gt; K)\n                Gang[Int2Str[head]] = numMember;\n        }\n    cout &lt;&lt; Gang.size() &lt;&lt; endl;\n    for(auto &amp;res : Gang) \n        cout &lt;&lt; res.first &lt;&lt; \" \" &lt;&lt; res.second &lt;&lt; endl;\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E5%9B%BE/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/PAT%20A1076_Forwards%20on%20Weibo/","title":"PAT A1076 Forwards on Weibo","text":"<p>\u601d\u8def\uff1a\u672c\u9898\u4e3a\u56fe\u7ed3\u6784\u7684\u904d\u5386\u9898\uff0c\u9898\u610f\u4e2d\u7ed9\u51fa\u8f6c\u53d1\u6b21\u6570\u4e0a\u9650\uff0c\u5373\u6309\u5c42\u6765\u904d\u5386\u90bb\u63a5\u7ed3\u70b9\uff0c\u5355\u6b65\u6b65\u957f\u4f7f\u7528BFS\u5373\u53ef\u89e3\u51b3\u3002\u6bcf\u6b21\u76f8\u90bb\u7684\u7ed3\u70b9\u5165\u961f\u65f6\uff0c\u5c42\u6570\u52a0\u4e00\uff0c\u5373\u8f6c\u53d1\u5c42\u6570\u7684\u9650\u5236\u3002</p> <pre><code>#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;cstring&gt;\n#include&lt;queue&gt;\nusing namespace std;\n\ntypedef struct {\n    int id, layer;\n} Node;\n\nconst int maxn = 1005;\nvector&lt;Node&gt; G[maxn];\nbool visit[maxn];\nint N, K, L;\n\nint BFS(int idQuery, int Layer) {\n    queue&lt;Node&gt; q;\n    Node s;\n    s.id = idQuery;\n    s.layer = 0;\n    q.push(s);\n    visit[s.id] = true;\n    int res = 0;\n    while(!q.empty()) {\n        Node t = q.front();\n        q.pop();\n        int id = t.id;\n        for(int i = 0; i &lt; G[id].size(); i++) {\n            Node next = G[id][i];\n            next.layer = t.layer + 1;\n            if(!visit[next.id] &amp;&amp; next.layer &lt;= L) {\n                q.push(next);\n                visit[next.id] = true;\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\nint main() {\n    cin &gt;&gt; N &gt;&gt; L;\n    Node user;\n    int numFollow, idFollow;\n    for(int i = 1; i &lt;= N; i++) {\n        user.id = i;\n        cin &gt;&gt; numFollow;\n        for(int j = 0; j &lt; numFollow; j++) {\n            cin &gt;&gt; idFollow;\n            G[idFollow].push_back(user);\n        }\n    }\n    cin &gt;&gt; K;\n    int idQuery;\n    for(int k = 0; k &lt; K; k++) {\n        cin &gt;&gt; idQuery;\n        memset(visit, false, sizeof(bool) * (N + 1));\n        int numForward = BFS(idQuery, L);\n        cout &lt;&lt; numForward &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E5%9B%BE/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/PAT%20A1003_Emergency/","title":"PAT A1003 Emergency","text":"<p>\u601d\u8def\uff1a\u5229\u7528Dijkstra\u7b97\u6cd5\uff0c\u4ece\u6e90\u70b9\u51fa\u53d1\u6c42\u51fa\u5230\u5176\u4ed6\u6240\u6709\u70b9\u7684\u6700\u77ed\u8def\u5f84\u6570\u91cf\u4ee5\u53ca\u70b9\u6743\u548c\u3002 <pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconst int maxn = 505;\nconst int INF = 1e9;\n\nint rescue[maxn], G[maxn][maxn];\nint weight[maxn], d[maxn], num[maxn];\nbool visit[maxn];\nint N, M, start, ed;\n\nvoid Dijkstra(int s) {\n    fill(d, d + maxn, INF);\n    d[s] = 0;\n    weight[s] = rescue[s];\n    num[s] = 1;\n    // \u6ce8\u610f\u8fd9\u91cc\u53ea\u9700\u8981\u5faa\u73af N - 1 \u6b21\n    // \u6bd4\u5982 N = 2 \u65f6\uff0c\u53ea\u9700\u8981 2 - 1 = 1 \u6b21\u5c31\u53ef\u4ee5\u5f97\u5230\u6700\u77ed\u8def\u5f84\n    for(int i = 0; i &lt; N - 1; i++) {\n        int u = -1, MIN = INF;\n        for(int j = 0; j &lt; N; j++) \n            if(!visit[j] &amp;&amp; d[j] &lt; MIN) {\n                u = j;\n                MIN = d[j];\n            }\n        if(u == -1) return;\n        visit[u] = true;\n        for(int v = 0; v &lt; N; v++) \n            if(!visit[v] &amp;&amp; G[u][v] != INF) {\n                if(d[u] + G[u][v] &lt; d[v]) {\n                    d[v] = d[u] + G[u][v];\n                    weight[v] = weight[u] + rescue[v];\n                    num[v] = num[u];\n                } else if(d[u] + G[u][v] == d[v]) {\n                    if(weight[u] + rescue[v] &gt; weight[v]) \n                        weight[v] = weight[u] + rescue[v];\n                    num[v] += num[u];\n                }\n            }\n    }\n}\n\nint main() {\n    cin &gt;&gt; N &gt;&gt; M &gt;&gt; start &gt;&gt; ed;\n    for(int i = 0; i &lt; N; i++)\n        cin &gt;&gt; rescue[i];\n    int u, v, w;\n    fill(G[0], G[0] + maxn * maxn, INF);\n    for(int i = 0; i &lt; M; i++) {\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        G[v][u] = G[u][v] = w;\n    }\n    Dijkstra(start);\n    cout &lt;&lt; num[ed] &lt;&lt; \" \" &lt;&lt; weight[ed] &lt;&lt; endl;\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E5%9B%BE/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/PAT%20A1018_Public%20Bike%20Management/","title":"PAT A1018 Public Bike Management","text":"<p>\u601d\u8def\uff1a\u5148\u4f7f\u7528Dijkstra\u7b97\u6cd5\u6c42\u51fa\u6700\u77ed\u8def\u5f84\uff0c\u4f7f\u7528pre\u8bb0\u5f55\u6700\u77ed\u8def\u5f84\u4e2d\u6bcf\u4e2a\u7ed3\u70b9\u7684\u524d\u9a71\u3002\u518d\u4f7f\u7528DFS\u4ece\u76ee\u6807\u7ed3\u70b9\u5f00\u59cb\u5012\u5e8f\u904d\u5386\u5230PBMC\uff0c\u6c42\u51fa\u5177\u6709\u6700\u5c0fNeed\u540c\u65f6\u5177\u6709\u6700\u5c0fremain\u7684\u8def\u5f84\u3002\u6ce8\u610f\uff0c\u5012\u5e8f\u904d\u5386\u5230PBMC\u4e4b\u540e\u624d\u5f00\u59cb\u8ba1\u7b97need\u548cremain\uff0c\u800c\u4e14\u5f53\u51fa\u73b0remain\u4e0d\u8db3\u5f53\u524d\u7ad9\u70b9\u6240\u9700\u81ea\u884c\u8f66\u6570\u91cf\u65f6\uff0c\u4e00\u5b9a\u9700\u8981\u4ecePBMC\u5e26\u6765\u81ea\u884c\u8f66\uff0c\u4e5f\u5c31\u662fneed\u5355\u8c03\u589e\u52a0\uff0c\u4e0d\u80fd\u4ece\u540e\u9762\u7684\u7ed3\u70b9\u4e2d\u5f97\u5230\u7684remain\u518d\u8865\u8d34\u524d\u9762\u7684\u7ed3\u70b9\u3002</p> <pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\nusing namespace std;\nconst int maxn = 505;\nconst int INF = 1e9;\n\nint Cmax, N, Sp, M;\nint minRemain = INF, minNeed = INF;\nint G[maxn][maxn], weight[maxn], d[maxn];\nbool visit[maxn];\nvector&lt;int&gt; pre[maxn], temp, ans;\n\nvoid Dijkstra(int s) {\n    fill(d, d + maxn, INF);\n    d[s] = 0;\n    for(int i = 0; i &lt; N; i++) {\n        int u = -1, MIN = INF;\n        for(int j = 0; j &lt;= N; j++) \n            if(!visit[j] &amp;&amp; d[j] &lt; MIN) {\n                u = j;\n                MIN = d[j];\n            }\n        if(u == -1) return;\n        visit[u] = true;\n        for(int v = 0; v &lt;= N; v++) \n            if(!visit[v] &amp;&amp; G[u][v] != INF) {\n                if(d[u] + G[u][v] &lt; d[v]) {\n                    d[v] = d[u] + G[u][v];\n                    pre[v].clear();\n                    pre[v].push_back(u);\n                } else if(d[u] + G[u][v] == d[v]) {\n                    pre[v].push_back(u);\n                }\n            }\n    }\n}\n\nvoid DFS(int s) {\n    if(s == 0) {\n        temp.push_back(s);\n        int need = 0, remain = 0;\n        for(int i = temp.size() - 1; i &gt;= 0; i--) {\n            int u = temp[i];\n            if(weight[u] &gt; 0) remain += weight[u];\n            else {\n                if(remain &gt; abs(weight[u]))\n                    remain -= abs(weight[u]);\n                else {\n                    need += abs(weight[u]) - remain;\n                    remain = 0;\n                }\n            }\n        }\n        if(need &lt; minNeed) {\n            minNeed = need;\n            minRemain = remain;\n            ans = temp;\n        } else if(need == minNeed &amp;&amp; remain &lt; minRemain) {\n            minRemain = remain;\n            ans = temp;\n        } \n        temp.pop_back();\n        return;\n    }\n    temp.push_back(s);\n    for(int i = 0; i &lt; pre[s].size(); i++)\n        DFS(pre[s][i]);\n    temp.pop_back();\n}\n\nint main() {\n    cin &gt;&gt; Cmax &gt;&gt; N &gt;&gt; Sp &gt;&gt; M;\n    for(int i = 1; i &lt;= N; i++) {\n        cin &gt;&gt; weight[i];\n        weight[i] -= Cmax / 2;\n    }\n    int u, v, w;\n    fill(G[0], G[0] + maxn * maxn, INF);\n    for(int i = 0; i &lt; M; i++) {\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        G[u][v] = G[v][u] = w;\n    }\n    Dijkstra(0);\n    DFS(Sp);\n    printf(\"%d \", minNeed);\n    for(int i = ans.size() - 1; i &gt;= 0; i--) {\n        printf(\"%d\", ans[i]);\n        if(i &gt; 0) printf(\"-&gt;\");\n    }\n    printf(\" %d\\n\", minRemain);\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E5%9B%BE/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/PAT%20A1030_Travel%20Plan/","title":"PAT A1030 Travel Plan","text":"<p>\u601d\u8def\uff1a\u6839\u636eDijkstra\u7b97\u6cd5\u6c42\u51fa\u6700\u77ed\u8def\u5f84\uff0c\u7528pre\u4fdd\u5b58\u8def\u5f84\u4e0a\u6bcf\u4e2a\u7ed3\u70b9\u7684\u524d\u9a71\u3002\u518d\u4f7f\u7528DFS\u4ece\u7ec8\u70b9\u8fdb\u884c\u5012\u5e8f\u904d\u5386\uff0c\u8bb0\u5f55\u4e0b\u6700\u5c0f\u7684cost\u5373\u4e3a\u7b54\u6848\u8def\u5f84\u3002 <pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nconst int MAXN = 505;\nconst int INF =1e9;\n\nint N, M, S, ed, minCost = INF;\nint G[MAXN][MAXN], cost[MAXN][MAXN], d[MAXN];\nbool visit[MAXN];\nvector&lt;int&gt; pre[MAXN], temp, ans;\n\nvoid Dijkstra(int s) {\n    fill(d, d + MAXN, INF);\n    d[s] = 0;\n    for(int i = 0; i &lt; N - 1; i++) {\n        int u = -1, MIN = INF;\n        for(int j = 0; j &lt; N; j++)\n            if(!visit[j] &amp;&amp; d[j] &lt; MIN) {\n                u = j;\n                MIN = d[j];\n            }\n        if(u == -1) return;\n        visit[u] = true;\n        for(int v = 0; v &lt; N; v++) \n            if(!visit[v] &amp;&amp; G[u][v] &lt; INF) {\n                if(d[u] + G[u][v] &lt; d[v]) {\n                    d[v] = d[u] + G[u][v];\n                    pre[v].clear();\n                    pre[v].push_back(u);\n                } else if(d[u] + G[u][v] == d[v]) {\n                    pre[v].push_back(u);\n                }\n            }\n    }\n}\n\nvoid DFS(int v) {\n    if(v == S) {\n        temp.push_back(v);\n        int nowCost = 0;\n        for(int i = temp.size() - 1; i &gt; 0; i--) {\n            int id = temp[i], id_next = temp[i - 1];\n            nowCost += cost[id][id_next];\n        }\n        if(nowCost &lt; minCost) {\n            minCost = nowCost;\n            ans = temp;\n        }\n        temp.pop_back();\n        return;\n    }\n    temp.push_back(v);\n    for(int i = 0; i &lt; pre[v].size(); i++) \n        DFS(pre[v][i]);\n    temp.pop_back();\n}\n\nint main() {\n    cin &gt;&gt; N &gt;&gt; M &gt;&gt; S &gt;&gt; ed;\n    int u, v, dist, c;\n    fill(G[0], G[0] + MAXN * MAXN, INF);\n    for(int i = 0; i &lt; M; i++) {\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; dist &gt;&gt; c;\n        G[u][v] = G[v][u] = dist;\n        cost[u][v] = cost[v][u] = c;\n    }\n    Dijkstra(S);\n    DFS(ed);\n    for(int i = ans.size() - 1; i &gt;= 0; i--) \n        printf(\"%d \", ans[i]);\n    printf(\"%d %d\\n\", d[ed], minCost);\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E5%9B%BE/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/PAT%20A1072_Gas%20Station/","title":"PAT A1072 Gas Station","text":"<p>\u601d\u8def\uff1a\u6ce8\u610f\u9996\u5148\u52a0\u6cb9\u7ad9\u5fc5\u987b\u6ee1\u8db3\u5230\u8fbe\u6240\u6709\u623f\u5c4b\u7684\u8ddd\u79bb\u4e0d\u8d85\u8fc7Ds\uff0c\u5728\u6b64\u57fa\u7840\u4e0a\uff0c\u8981\u4f7f\u6700\u8fd1\u7684\u8ddd\u79bb\u6700\u5927\u3002\u5f53\u51fa\u73b0\u591a\u4e2a\u6700\u8fd1\u8ddd\u79bb\u6700\u5927\u7684\u89e3\u7684\u65f6\u5019\uff0c\u9009\u62e9\u5e73\u5747\u8ddd\u79bb\u6700\u5c0f\u7684\u89e3\uff0c\u4f18\u5148\u9009\u62e9\u7d22\u5f15\u66f4\u5c0f\u7684\u4f4d\u7f6e\u3002\u4f7f\u7528M\u6b21Dijkstra\u7b97\u6cd5\u5c06M\u4e2a\u52a0\u6cb9\u7ad9\u4f4d\u7f6e\u5168\u90e8\u904d\u5386\u4e00\u904d\u53ef\u5f97\u5230\u7b54\u6848\u3002</p> <pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\n\nconst int MAXN = 1015;\nconst int INF = 1e9;\n\nint N, M, K, Ds;\nint G[MAXN][MAXN], d[MAXN];\nbool visit[MAXN];\nint ansGas = -1;\ndouble ansDist = -1, ansAvg = INF;\n\nint transform(string s) {\n    if(s[0] != 'G') return stoi(s);\n    return stoi(s.substr(1)) + N;\n}\n\nvoid Dijkstra(int s) {\n    fill(d, d + MAXN, INF);\n    fill(visit, visit + MAXN, false);\n    d[s] = 0;\n    for(int i = 0; i &lt; N + M; i++) {\n        int u = -1, MIN = INF;\n        for(int j = 1; j &lt;= N + M; j++)\n            if(!visit[j] &amp;&amp; d[j] &lt; MIN) {\n                u = j;\n                MIN = d[j];\n            }\n        if(u == -1) return;\n        visit[u] = true;\n        for(int v = 1; v &lt;= N + M; v++)\n            if(!visit[v] &amp;&amp; d[u] + G[u][v] &lt; d[v]) \n                d[v] = d[u] + G[u][v];\n    }\n}\n\nint main() {\n    cin &gt;&gt; N &gt;&gt; M &gt;&gt; K &gt;&gt; Ds;\n    string p1, p2;\n    int id1, id2, dist;\n    fill(G[0], G[0] + MAXN * MAXN, INF);\n    for(int i = 0; i &lt; K; i++) {\n        cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; dist;\n        id1 = transform(p1);\n        id2 = transform(p2);\n        G[id1][id2] = G[id2][id1] = dist;\n    }\n    double avg, minDist;\n    for(int i = N + 1; i &lt;= N + M; i++) {\n        Dijkstra(i);\n        minDist = INF, avg = 0;\n        for(int j = 1; j &lt;= N; j++) {\n            if(d[j] &gt; Ds) {\n                minDist = -1;\n                break;\n            }\n            if(d[j] &lt; minDist) minDist = d[j];\n            avg += d[j];\n        }    \n        avg /= N;\n        if(minDist == -1) continue;\n        if(minDist &gt; ansDist) {\n            ansDist = minDist;\n            ansGas = i;\n            ansAvg = avg;\n        } else if(minDist == ansDist &amp;&amp; avg &lt; ansAvg) {\n            ansGas = i;\n            ansAvg = avg;\n        }\n    }\n    if(ansGas == -1) cout &lt;&lt; \"No Solution\" &lt;&lt; endl;\n    else {\n        cout &lt;&lt; \"G\" &lt;&lt; ansGas - N &lt;&lt; endl;\n        printf(\"%.1f %.1f\\n\", ansDist, ansAvg);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E5%9B%BE/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/PAT%20A1087_All%20Roads%20Lead%20to%20Rome/","title":"PAT A1087 All Roads Lead to Rome","text":"<p>\u601d\u8def\uff1a\u53ef\u91c7\u7528Dijkstra\u6216Dijkstra + DFS\u7684\u505a\u6cd5\u3002\u4f7f\u7528Dijkstra\u65f6\u6ce8\u610f\u4f18\u5148\u5904\u7406\u6700\u77ed\u8def\u5f84\uff0c\u5176\u6b21\u662f\u5e78\u798f\u503c\uff0c\u6700\u540e\u662f\u5e73\u5747\u5e78\u798f\u503c\u3002\u6253\u5370\u8def\u5f84\u65f6\u53ef\u4ee5\u901a\u8fc7\u4e00\u7ef4pre\u6570\u7ec4\u9012\u5f52\u5f97\u5230\u3002</p> <pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;cstdio&gt;\n#include&lt;map&gt;\n#include&lt;string&gt;\nusing namespace std;\nconst int MAXN = 205;\nconst int INF = 1E9;\n\nint G[MAXN][MAXN], weight[MAXN], d[MAXN];\nint happy[MAXN], pt[MAXN], pre[MAXN], num[MAXN];\nbool visit[MAXN];\nmap&lt;int, string&gt; Int2Str;\nmap&lt;string, int&gt; Str2Int;\nint N, K;\n\nvoid Dijkstra(int s) {\n    fill(d, d + MAXN, INF);\n    d[s] = 0;\n    happy[s] = weight[s];\n    num[s] = 1;\n    for(int i = 0; i &lt; N; i++) {\n        int u = -1, MIN = INF;\n        for(int j = 0; j &lt; N; j++) \n            if(!visit[j] &amp;&amp; d[j] &lt; MIN) {\n                u = j;\n                MIN = d[j];\n            }\n        if(u == -1) return;\n        visit[u] = true;\n        for(int v = 0; v &lt; N; v++) \n            if(!visit[v] &amp;&amp; d[u] + G[u][v] &lt; d[v]) {\n                d[v] = d[u] + G[u][v];\n                happy[v] = happy[u] + weight[v];\n                num[v] = num[u];\n                pt[v] = pt[u] + 1;\n                pre[v] = u;\n            } else if(!visit[v] &amp;&amp; d[u] + G[u][v] == d[v]) {\n                num[v] += num[u];\n                if(happy[u] + weight[v] &gt; happy[v]) {\n                    happy[v] = happy[u] + weight[v];\n                    pt[v] = pt[u] + 1;\n                    pre[v] = u;\n                } else if(happy[u] + weight[v] == happy[v]) {\n                    double uAvg = 1.0 * (happy[u] + weight[v]) / (pt[u] + 1);\n                    double vAvg = 1.0 * happy[v] / pt[v];\n                    if(uAvg &gt; vAvg) {\n                        pt[v] = pt[u] + 1;\n                        pre[v] = u;\n                    }\n                }\n            }\n    }\n}\n\nvoid printPath(int v) {\n    if(v == 0) {\n        cout &lt;&lt; Int2Str[v];\n        return;\n    }\n    printPath(pre[v]);\n    cout &lt;&lt; \"-&gt;\" &lt;&lt; Int2Str[v];\n}\n\nint main() {\n    string city1, city2;\n    cin &gt;&gt; N &gt;&gt; K &gt;&gt; city1;\n    Str2Int[city1] = 0;\n    Int2Str[0] = city1;\n    for(int i = 1; i &lt;= N - 1; i++) {\n        cin &gt;&gt; city1 &gt;&gt; weight[i];\n        Int2Str[i] = city1;\n        Str2Int[city1] = i;\n    }\n    int w, id1, id2;\n    fill(G[0], G[0] + MAXN * MAXN, INF);\n    for(int i = 0; i &lt; K; i++) {\n        cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; w;\n        id1 = Str2Int[city1];\n        id2 = Str2Int[city2];\n        G[id1][id2] = G[id2][id1] = w;\n    }\n    Dijkstra(0);\n    int id_rom = Str2Int[\"ROM\"];\n    printf(\"%d %d %d %d\\n\", num[id_rom], d[id_rom], happy[id_rom], happy[id_rom] / pt[id_rom]);\n    printPath(id_rom);\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E5%A0%86/PAT%20A1098_Insertion%20or%20Heap%20Sort/","title":"PAT A1098 Insertion or Heap Sort","text":"<p>\u601d\u8def\uff1a\u672c\u9898\u8003\u5bdf\u5806\u6392\u5e8f\u7684\u5177\u4f53\u8fc7\u7a0b\u3002\u6ce8\u610f\u9898\u76ee\u7ed9\u51fa\u521d\u59cb\u5e8f\u5217\u4e0d\u5305\u542b\u5728\u4e2d\u95f4\u5e8f\u5217\u91cc\u3002\u5806\u6392\u5e8f\u65f6\uff0c\u82e5\u8981\u8fdb\u884c\u9012\u589e\u6392\u5e8f\uff0c\u9996\u5148\u5e94\u8be5\u4ece\u6700\u540e\u4e00\u4e2a\u975e\u53f6\u7ed3\u70b9\u5f00\u59cb\uff0c\u5c06\u5176\u4e0e\u952e\u503c\u66f4\u5927\u7684\u5b50\u8282\u70b9\u8fdb\u884c\u4e92\u6362\u8c03\u6574\uff0c\u7c7b\u4f3c\u4e8e\u5efa\u7acb\u5927\u6839\u5806\u3002\u5efa\u5806\u4e4b\u540e\uff0c\u6bcf\u6b21\u5c06\u5806\u9876\u5143\u7d20\u653e\u5230\u5806\u7684\u672b\u5c3e\uff0c\u5c06\u5806\u5927\u5c0f\u51cf\u4e00\uff0c\u91cd\u590d\u8fd9\u4e2a\u8fc7\u7a0b\u76f4\u5230\u5806\u7684\u5927\u5c0f\u4e3a1\uff0c\u6392\u5e8f\u5b8c\u6210\u3002 <pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nconst int maxn = 105;\n\nint origin[maxn];\nint temp[maxn];\nint intermediate[maxn];\nint n;\n\nvoid printArray(int a[], int size) {\n    for(int i = 1; i &lt;= size; i++) {\n        printf(\"%d\", a[i]);\n        if(i &lt; size) printf(\" \");\n    }\n}\n\nbool isArrEqual(int a[], int b[], int size) {\n    for(int i = 1; i &lt;= size; i++)\n        if(a[i] != b[i]) return false;\n    return true;\n}\n\nbool isInsert() {\n    bool flag = false;\n    for(int i = 2; i &lt;= n; i++) {\n        if(i != 2 &amp;&amp; isArrEqual(temp, intermediate, n)) \n            flag = true;\n        sort(temp + 1, temp + i + 1);\n        if(flag) return true;\n    }\n    return false;\n}\n\nvoid downAdjust(int low, int high) {\n    int i = low, j = 2 * i;\n    while(j &lt;= high) {\n        if(j + 1 &lt;= high &amp;&amp; temp[j + 1] &gt; temp[j])\n            j = j + 1;\n        if(temp[j] &gt; temp[i]) {\n            swap(temp[i], temp[j]);\n            i = j;\n            j = 2 * i;\n        } else  {\n            break;\n        }\n    }\n}\n\nvoid HeapSort() {\n    for(int i = 1; i &lt;= n; i++)\n        temp[i] = origin[i];\n    for(int i = n / 2; i &gt;= 1; i--)\n        downAdjust(i, n);\n    bool flag = false;\n    for(int i = n; i &gt; 1; i--) {\n        if(i != n &amp;&amp; isArrEqual(temp, intermediate, n))\n            flag = true;\n        swap(temp[i], temp[1]);\n        downAdjust(1, i - 1);\n        if(flag) return;\n    }\n}\n\nint main() {\n    scanf(\"%d\", &amp;n);\n    for(int i = 1; i &lt;= n; i++) {\n        scanf(\"%d\", &amp;origin[i]);\n        temp[i] = origin[i];\n    }\n    for(int i = 1; i &lt;= n; i++)\n        scanf(\"%d\", &amp;intermediate[i]);\n    if(isInsert()) {\n        printf(\"Insertion Sort\\n\");\n        printArray(temp, n);\n    } else {\n        printf(\"Heap Sort\\n\");\n        HeapSort();\n        printArray(temp, n);\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/PAT%20A1005_Spell%20It%20Right/","title":"PAT A1005 Spell It Right","text":"<p>\u601d\u8def\uff1a\u5148\u628a\u8f93\u5165\u5f53\u6210\u5b57\u7b26\u4e32\uff0c\u6c42\u51fa\u6bcf\u4f4d\u548c sum \u540e\u5c06 sum \u8f6c\u5316\u6210\u5b57\u7b26\u4e32\u8f93\u51fa\u5355\u8bcd\u3002 <pre><code>#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\n\nstring s;\nint sum;\n\nvoid numToWord(char ch) {\n    if(ch == '0') cout &lt;&lt; \"zero\";\n    else if(ch == '1') cout &lt;&lt; \"one\";\n    else if(ch == '2') cout &lt;&lt; \"two\";\n    else if(ch == '3') cout &lt;&lt; \"three\";\n    else if(ch == '4') cout &lt;&lt; \"four\";\n    else if(ch == '5') cout &lt;&lt; \"five\";\n    else if(ch == '6') cout &lt;&lt; \"six\";\n    else if(ch == '7') cout &lt;&lt; \"seven\";\n    else if(ch == '8') cout &lt;&lt; \"eight\";\n    else if(ch == '9') cout &lt;&lt; \"nine\";\n} \n\nint main() {\n    cin &gt;&gt; s;\n    for(auto ch : s) sum += (ch - '0');\n    s = to_string(sum);\n    for(int i = 0; i &lt; s.size(); i++) {\n        numToWord(s[i]);\n        if(i &lt; s.size() - 1) cout &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/PAT%20A1060_Are%20They%20Equal/","title":"PAT A1060 Are They Equal","text":"<p>\u601d\u8def\uff1a\u6ce8\u610f\u5904\u7406\u524d\u5bfc\u96f6\u4ee5\u53ca\u5c0f\u6570\u70b9\u6bd4\u5982000100.00123\u548c000.123\u4e24\u79cd\u60c5\u51b5\uff0c\u4ee5\u53ca\u65e0\u5c0f\u6570\u70b9\u7684000123456\u7b49 <pre><code>#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\n\nint n;\n\nstring normalize(string s, int &amp;e) {\n    while(s.length() &gt; 0 &amp;&amp; s[0] == '0')\n        s.erase(s.begin());\n    if(s[0] == '.') {\n        s.erase(s.begin());\n        while(s.length() &gt; 0 &amp;&amp; s[0] == '0') {\n            s.erase(s.begin());\n            e--;\n        }\n    } \n    else {\n        int k = 0; \n        while(k &lt; s.length() &amp;&amp; s[k] != '.') {\n            k++;\n            e++;\n        }\n        if(k &lt; s.length()) {\n            s.erase(s.begin() + k);\n        }\n    }\n    if(s.length() == 0) {\n        e = 0;\n    }\n    int num = 0, idx = 0;\n    string res;\n    while(num &lt; n) {\n        if(idx &lt; s.length()) {\n            res += s[idx];\n            ++idx;\n        } else {\n            res += \"0\";\n        }\n        num++;\n    }\n    return res;\n}\n\nint main() {\n    string s1, s2;\n    cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2;\n    int e1 = 0, e2 = 0;\n    s1 = normalize(s1, e1);\n    s2 = normalize(s2, e2);\n    if(s1 == s2 &amp;&amp; e1 == e2) {\n        cout &lt;&lt; \"YES 0.\" &lt;&lt; s1 &lt;&lt; \"*10^\" &lt;&lt; e1 &lt;&lt; endl;\n    } else {\n        cout &lt;&lt; \"NO 0.\" &lt;&lt; s1 &lt;&lt; \"*10^\" &lt;&lt; e1 &lt;&lt; \" 0.\" &lt;&lt; s2 &lt;&lt; \"*10^\" &lt;&lt; e2 &lt;&lt; endl;        \n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E5%B9%B6%E6%9F%A5%E9%9B%86/PAT%20A1107_Social%20Clusters/","title":"PAT A1107 Social Clusters","text":"<p>\u601d\u8def\uff1a\u5c06\u6700\u5148\u559c\u6b22\u67d0\u4e2a\u7231\u597d\u7684\u4eba\u4f5c\u4e3a\u6839\u8282\u70b9\uff0c\u4f7f\u7528\u5e76\u67e5\u96c6\u8fdb\u884c\u89e3\u9898 <pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\n#include&lt;functional&gt;\nusing namespace std;\n\nconst int maxn = 1005;\n\nint hobby[maxn];\nint father[maxn];\nint res[maxn];\n\nint n;\n\nint findFather(int x) {\n    int temp = x;\n    while(father[x] != x) {\n        x = father[x];\n    }\n    int a;\n    while(father[temp] != temp) {\n        a = temp;\n        temp = father[temp];\n        father[a] = x;\n    }\n    return x;\n}\n\nvoid Union(int a, int b) {\n    int fa = findFather(a);\n    int fb = findFather(b);\n    if(fa != fb) {\n        father[fa] = fb;\n    }\n}\n\nint main() {\n    scanf(\"%d\", &amp;n);\n    for(int i = 1; i &lt;= n; i++)\n        father[i] = i;\n    int num, temp;\n    for(int i = 1; i &lt;= n; i++) {\n        scanf(\"%d:\", &amp;num);\n        for(int j = 0; j &lt; num; j++) {\n            scanf(\"%d\", &amp;temp);\n            if(hobby[temp] == 0) {\n                hobby[temp] = i;\n            }\n            Union(i, findFather(hobby[temp]));\n        }\n    }\n    int ans = 0;\n    for(int i = 1; i &lt;= n; i++) \n        res[findFather(i)]++;\n    for(int i = 1; i &lt;= n; i++) \n        if(res[i] != 0) ans++;\n    printf(\"%d\\n\", ans);\n    sort(res + 1, res + 1 + n, greater&lt;int&gt;());\n    for(int i = 1; i &lt;= ans; i++) {\n        printf(\"%d\", res[i]);\n        if(i &lt; ans) printf(\" \");\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E6%8E%92%E5%BA%8F/PAT%20A1012_The%20Best%20Rank/","title":"PAT A1012 The Best Rank","text":"<p>\u601d\u8def\uff1a\u6839\u636e\u56db\u79cd\u6210\u7ee9\u8fdb\u884c\u56db\u6b21\u6392\u5e8f\uff0c\u4f7f\u7528 Rank \u6570\u7ec4\u4fdd\u5b58\u8fd9\u56db\u79cd\u6392\u5e8f\u4e2d\u6700\u5c0f\u7684\u6570\u5b57\u4f5c\u4e3a\u67e5\u8be2\u7ed3\u679c\u3002\u6ce8\u610f\u8be5\u76f8\u540c\u5206\u6570\u65f6\u6392\u540d\u76f8\u540c\u3002</p> <pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconst int MAXN = 2005;\n\ntypedef struct {\n    int id;\n    int grade[4];\n} Student;\n\nStudent stu[MAXN];\nint Rank[1000000][4], now;\nchar mp[4] = {'A', 'C', 'M', 'E'};\n\nint N, M;\n\nbool cmp(Student a, Student b) {\n    return a.grade[now] &gt; b.grade[now];\n}\n\nint main() {\n    cin &gt;&gt; N &gt;&gt; M;\n    for(int i = 0; i &lt; N; i++) {\n        cin &gt;&gt; stu[i].id &gt;&gt; stu[i].grade[1] &gt;&gt; stu[i].grade[2] &gt;&gt; stu[i].grade[3];\n        stu[i].grade[0] = stu[i].grade[1] + stu[i].grade[2] +stu[i].grade[3];\n    }\n    for(now = 0; now &lt; 4; now++) {\n        sort(stu, stu + N, cmp);\n        Rank[stu[0].id][now] = 1;\n        for(int i = 1; i &lt; N; i++) {\n            if(stu[i].grade[now] == stu[i - 1].grade[now]) {\n                Rank[stu[i].id][now] = Rank[stu[i - 1].id][now];\n            } else {\n                Rank[stu[i].id][now] = i + 1;\n            }\n        }\n    }\n    int q;\n    for(int i = 0; i &lt; M; i++) {\n        cin &gt;&gt; q;\n        if(Rank[q][0] == 0) {\n            cout &lt;&lt; \"N/A\\n\";\n        } else {\n            int k = 0;\n            for(int j = 0; j &lt; 4; j++) {\n                if(Rank[q][j] &lt; Rank[q][k]) {\n                    k = j;\n                }\n            }\n            cout &lt;&lt; Rank[q][k] &lt;&lt; \" \" &lt;&lt; mp[k] &lt;&lt; endl;\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E6%8E%92%E5%BA%8F/PAT%20A1016_Phone%20Bills/","title":"PAT A1016 Phone Bills","text":"<p>\u601d\u8def\uff1a\u5c06\u8f93\u5165\u7684\u4fe1\u606f\u5c01\u88c5\u6210\u7ed3\u6784\uff0c\u6839\u636e\u65f6\u95f4\u987a\u5e8f\u8fdb\u884c\u6392\u5e8f\u3002\u9488\u5bf9\u6bcf\u4e2a\u7528\u6237\u5148\u5bfb\u627e\u662f\u5426\u5b58\u5728 on \u5728\u524d\uff0coff \u5728\u540e\u7684\u60c5\u51b5\uff0c\u5b58\u5728\u5219\u4e00\u5b9a\u9700\u8981\u8f93\u51fa\u3002 \u627e\u5230\u4e4b\u540e\u5bfb\u627e\u6240\u6709\u6709\u6548\u8bb0\u5f55\uff0c\u5e76\u4ee5\u5206\u949f\u4e3a\u5355\u4f4d\u8fdb\u884c money \u548c time \u7684\u8ba1\u7b97\uff0c\u6ce8\u610f\u9898\u76ee\u7ed9\u51fa\u7684\u662f\u7f8e\u5206/\u6bcf\u5206\u949f\uff0c\u6700\u540e\u8ba1\u7b97\u662f\u7528\u7f8e\u5143\u505a\u5355\u4f4d\uff0c\u8fdb\u5236\u4e3a 100\u3002</p> <pre><code>#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconst int MAXN = 1005;\n\ntypedef struct {\n    string name;\n    int dd, hh, mm, month;\n    bool isOnline;\n} Record;\n\nRecord rec[MAXN], temp;\n\nint toll[30], N;\n\nbool cmp(Record a, Record b) {\n    if(a.name != b.name) return a.name &lt; b.name;\n    else if(a.month != b.month) return a.month &lt; b.month;\n    else if(a.dd != b.dd) return a.dd &lt; b.dd;\n    else if(a.hh != b.hh) return a.hh &lt; b.hh;\n    else return a.mm &lt; b.mm;\n}\n\nvoid proc_valid(int on, int off, int&amp; time, int&amp; money) {\n    temp = rec[on];\n    while(temp.dd &lt; rec[off].dd || temp.hh &lt; rec[off].hh || temp.mm &lt; rec[off].mm) {\n        time++;\n        money += toll[temp.hh];\n        temp.mm++;\n        if(temp.mm &gt;= 60) {\n            temp.mm = 0;\n            temp.hh++;\n        }\n        if(temp.hh &gt;= 24) {\n            temp.hh = 0;\n            temp.dd++;\n        }\n    }\n}\n\nint main() {\n    for(int i = 0; i &lt; 24; i++)\n        cin &gt;&gt; toll[i];\n    cin &gt;&gt; N;\n    string status;\n    for(int i = 0; i &lt; N; i++) {\n        cin &gt;&gt; rec[i].name;\n        scanf(\"%d:%d:%d:%d\", &amp;rec[i].month, &amp;rec[i].dd, &amp;rec[i].hh, &amp;rec[i].mm);\n        cin &gt;&gt; status;\n        if(status == \"on-line\") \n            rec[i].isOnline = true;\n        else \n            rec[i].isOnline = false;\n    }\n    sort(rec, rec + N, cmp);\n    // next \u662f\u4e0b\u4e00\u4e2a\u7528\u6237\n    int on = 0, off, next, needPrint;\n    while(on &lt; N) {\n        // needPrint \u4e3a\u662f\u5426\u9700\u8981\u8f93\u51fa\n        needPrint = 0;\n        next = on;\n        while(next &lt; N &amp;&amp; rec[next].name == rec[on].name) {\n            if(needPrint == 0 &amp;&amp; rec[next].isOnline) {\n                needPrint = 1;\n            } else if(needPrint == 1 &amp;&amp; !rec[next].isOnline) {\n                needPrint = 2;\n            }\n            next++;\n        }\n        if(needPrint != 2) {\n            on = next;\n            continue;\n        }\n        cout &lt;&lt; rec[on].name &lt;&lt; \" \";\n        printf(\"%02d\\n\", rec[on].month);\n        // \u8f93\u51fa\u6240\u6709\u914d\u5bf9\n        int totalMoney = 0;\n        while(on &lt; next) {\n            while(on &lt; next - 1 &amp;&amp; !(rec[on].isOnline &amp;&amp; !rec[on + 1].isOnline)) {\n                on++;\n            }\n            off = on + 1;\n            if(off == next) {\n                on = next;\n                break;\n            }\n            printf(\"%02d:%02d:%02d \", rec[on].dd, rec[on].hh, rec[on].mm);\n            printf(\"%02d:%02d:%02d \", rec[off].dd, rec[off].hh, rec[off].mm);\n            int money = 0, time = 0;\n            // \u6ce8\u610f\u5f97\u5230\u7684 money \u4e3a cent \u800c\u975e dollar\n            proc_valid(on, off, time, money);\n            totalMoney += money;\n            printf(\"%d $%.2f\\n\", time, money / 100.0);\n            on = off + 1;\n        }\n        printf(\"Total amount: $%.2f\\n\", totalMoney / 100.0);\n    }\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E6%8E%92%E5%BA%8F/PAT%20A1062_Talent%20and%20Virtue/","title":"PAT A1062 Talent and Virtue","text":"<p>\u601d\u8def\uff1a\u8f93\u5165\u53ef\u5206\u4e3a 1. \u5fb7\u624d &gt;= H  2. \u5fb7 &gt;= H\uff0c\u624d &lt; H  3. \u5fb7 &gt;= \u624d  4. \u5fb7\u624d &gt;= L  5. \u5fb7\u6216\u624d &lt; L \u5171 5 \u6863</p> <p>\u6b64\u5916\uff0c\u5148\u6309\u6863\u6b21\uff0c\u5176\u6b21\u603b\u5206\uff0c\u518d\u6309\u5fb7\u5206\uff0c\u6700\u540e\u6309 id\uff0c\u4ee5\u6b64\u4e3a\u4f9d\u636e\u8fdb\u884c\u6392\u5e8f\u3002</p> <pre><code>#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconst int MAXN = 100005;\n\ntypedef struct {\n    string id;\n    int vg, tg, sum, flag;\n} Student;\n\nStudent stu[MAXN];\n\nint N, L, H;\n\nbool cmp(Student a, Student b) {\n    if(a.flag != b.flag) return a.flag &lt; b.flag;\n    else if(a.sum != b.sum) return a.sum &gt; b.sum;\n    else if(a.vg != b.vg) return a.vg &gt; b.vg;\n    return a.id &lt; b.id;\n}\n\nint main() {\n    cin &gt;&gt; N &gt;&gt; L &gt;&gt; H;\n    int M = N;\n    for(int i = 0; i &lt; N; i++) {\n        cin &gt;&gt; stu[i].id &gt;&gt; stu[i].vg &gt;&gt; stu[i].tg;\n        stu[i].sum = stu[i].vg + stu[i].tg;\n        if(stu[i].vg &lt; L || stu[i].tg &lt; L) {\n            stu[i].flag = 5;\n            M--;\n        } else if(stu[i].vg &gt;= H &amp;&amp; stu[i].tg &gt;= H) {\n            stu[i].flag = 1;\n        } else if(stu[i].vg &gt;= H &amp;&amp; stu[i].tg &lt; H) {\n            stu[i].flag = 2;\n        } else if(stu[i].vg &gt;= stu[i].tg) {\n            stu[i].flag = 3;\n        } else {\n            stu[i].flag = 4;\n        }\n    }\n    sort(stu, stu + N, cmp);\n    cout &lt;&lt; M &lt;&lt; endl;\n    for(int i = 0; i &lt; M; i++) {\n        cout &lt;&lt; stu[i].id &lt;&lt; \" \" &lt;&lt; stu[i].vg &lt;&lt; \" \" &lt;&lt; stu[i].tg &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A0%88/PAT%20A1051_Pop%20Sequence/","title":"PAT A1051 Pop Sequence","text":"<p>\u601d\u8def\uff1a\u7528\u6808\u6765\u6a21\u62df\u7ed9\u5b9a\u51fa\u6808\u987a\u5e8f\u7684\u8fc7\u7a0b\u5373\u53ef <pre><code>#include&lt;cstdio&gt;\n#include&lt;stack&gt;\nusing namespace std;\n\nconst int maxn = 1005;\nint m, n, k;\nint seq[maxn];\n\nint main() {\n    scanf(\"%d %d %d\", &amp;m, &amp;n, &amp;k);\n    stack&lt;int&gt; st;\n    while(k--) {\n        while(!st.empty()) st.pop();\n        for(int i = 0; i &lt; n; i++) {\n            scanf(\"%d\", &amp;seq[i]);\n        }\n        int idx = 0;\n        bool flag = true;\n        for(int i = 1; i &lt;= n; i++) {\n            st.push(i);\n            if(st.size() &gt; m) {\n                flag = false;\n                break;\n            }\n            while(!st.empty() &amp;&amp; st.top() == seq[idx]) {\n                st.pop();\n                idx++;\n            }\n        }\n        if(st.empty() &amp;&amp; flag == true) \n            printf(\"YES\\n\");\n        else printf(\"NO\\n\");\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/PAT%20A1043_Is%20it%20a%20Binary%20Search%20Tree/","title":"PAT A1043 Is it a Binary Search Tree","text":"<p>\u601d\u8def\uff1a\u76f4\u63a5\u8fdb\u884c\u5efa\u6811\u7136\u540e\u4e0e\u8f93\u5165\u5e8f\u5217\u8fdb\u884c\u5bf9\u6bd4\uff0c\u6ce8\u610f\u955c\u50cf\u5e8f\u5217\u5373\u5bf9\u6362\u5de6\u53f3\u904d\u5386\u987a\u5e8f <pre><code>#include&lt;cstdio&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\ntypedef struct Node Node;\n\nstruct Node {\n    int data;\n    Node* left, *right;\n};\n\nvoid insert(Node* &amp;root, int data) {\n    if(root == NULL) {\n        root = new Node;\n        root-&gt;data = data;\n        root-&gt;left = NULL;\n        root-&gt;right = NULL;\n        return;\n    }\n    if(data &lt; root-&gt;data) insert(root-&gt;left, data);\n    else insert(root-&gt;right, data);\n}\n\nvoid preOrder(Node* root, vector&lt;int&gt;&amp; pre) {\n    if(root == NULL) return;\n    pre.push_back(root-&gt;data);\n    preOrder(root-&gt;left, pre);\n    preOrder(root-&gt;right, pre);\n}\n\nvoid mPreOrder(Node* root, vector&lt;int&gt;&amp; mPre) {\n    if(root == NULL) return;\n    mPre.push_back(root-&gt;data);\n    mPreOrder(root-&gt;right, mPre);\n    mPreOrder(root-&gt;left, mPre);\n}\n\nvoid postOrder(Node* root, vector&lt;int&gt;&amp; post) {\n    if(root == NULL) return;\n    postOrder(root-&gt;left, post);\n    postOrder(root-&gt;right, post);\n    post.push_back(root-&gt;data);\n}\n\nvoid mPostOrder(Node* root, vector&lt;int&gt;&amp; mPost) {\n    if(root == NULL) return;\n    mPostOrder(root-&gt;right, mPost);\n    mPostOrder(root-&gt;left, mPost);\n    mPost.push_back(root-&gt;data);\n}\n\n\nint main() {\n    int n;\n    scanf(\"%d\", &amp;n);\n    int data;\n    Node* root = NULL;\n    vector&lt;int&gt; origin;\n    for(int i = 0; i &lt; n; i++) {\n        scanf(\"%d\", &amp;data);\n        insert(root, data);\n        origin.push_back(data);\n    }\n    vector&lt;int&gt; pre, mPre, post, mPost;\n    preOrder(root, pre);\n    mPreOrder(root, mPre);\n    if(origin == pre) {\n        printf(\"YES\\n\");\n        postOrder(root, post);\n        for(int i = 0; i &lt; post.size(); i++) {\n            printf(\"%d\", post[i]);\n            if(i &lt; post.size() - 1)\n                printf(\" \");\n            else printf(\"\\n\");\n        }\n    } else if(origin == mPre) {\n        printf(\"YES\\n\");\n        mPostOrder(root, mPost);\n        for(int i = 0; i &lt; mPost.size(); i++) {\n            printf(\"%d\", mPost[i]);\n            if(i &lt; mPost.size() - 1)\n                printf(\" \");\n            else printf(\"\\n\");\n        }\n    } else {\n        printf(\"NO\\n\");\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/PAT%20A1064_Complete%20Binary%20Search%20Tree/","title":"PAT A1064 Complete Binary Search Tree","text":"<p>\u601d\u8def\uff1a\u5229\u7528\u6570\u7ec4\u5efa\u7acb\u5b8c\u5168\u4e8c\u53c9\u6811\uff0c\u6570\u7ec4\u6309\u987a\u5e8f\u904d\u5386\u5373\u4e3a\u5b8c\u5168\u4e8c\u53c9\u6811\u7684\u5c42\u5e8f\u904d\u5386 <pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconst int maxn = 1005;\n\nint CBT[maxn], val[maxn];\nint n, index;\n\nvoid inOrder(int root) {\n    if(root &gt; n) return;\n    inOrder(2 * root);\n    CBT[root] = val[index++];\n    inOrder(2 * root + 1);\n}\n\nint main() {\n    scanf(\"%d\", &amp;n);\n    for(int i = 0; i &lt; n; i++) {\n        scanf(\"%d\", &amp;val[i]);\n    }\n    sort(val, val + n);\n    inOrder(1);\n    for(int i = 1; i &lt;= n; i++) {\n        printf(\"%d\", CBT[i]);\n        if(i &lt; n) printf(\" \");\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/PAT%20A1099_Build%20a%20Binary%20Search%20Tree/","title":"PAT A1099 Build a Binary Search Tree","text":"<p>\u601d\u8def\uff1a\u6839\u7ed3\u70b9\u9ed8\u8ba4\u4e3a0\uff0c\u7528\u9759\u6001\u6570\u7ec4\u5efa\u6811\uff0c\u8f93\u5165\u7684\u952e\u503c\u8fdb\u884c\u9012\u589e\u6392\u5e8f\u3002\u6309\u7167\u4e2d\u5e8f\u904d\u5386\u7684\u987a\u5e8f\u5bf9\u6bcf\u4e2a\u7ed3\u70b9\u586b\u5165\u952e\u503c\uff0c\u6700\u540eBFS\u6c42\u5f97\u5c42\u5e8f\u904d\u5386\u7b54\u6848\u3002 <pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\n#include&lt;queue&gt;\nusing namespace std;\n\nconst int maxn = 105;\n\ntypedef struct {\n    int val, left, right;\n} Node;\n\nNode node[maxn];\nint n, key[maxn], index;\n\nvoid inOrder(int root) {\n    if(root == -1) return;\n    inOrder(node[root].left);\n    node[root].val = key[index++];\n    inOrder(node[root].right);\n}\n\nvoid BFS(int root) {\n    queue&lt;int&gt; q;\n    q.push(root);\n    while(!q.empty()) {\n        int temp = q.front();\n        q.pop();\n        printf(\"%d\", node[temp].val);\n        index++;\n        if(index &lt; n) printf(\" \");\n        if(node[temp].left != -1) q.push(node[temp].left);\n        if(node[temp].right != -1) q.push(node[temp].right);\n    }\n}\n\nint main() {\n    scanf(\"%d\", &amp;n);\n    for(int i = 0; i &lt; n; i++) \n        scanf(\"%d %d\", &amp;node[i].left, &amp;node[i].right);\n    for(int i = 0; i &lt; n; i++)\n        scanf(\"%d\", &amp;key[i]);\n    sort(key, key + n);\n    inOrder(0);\n    index = 0;\n    BFS(0);\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/PAT%20A1020_Tree%20Traversals/","title":"PAT A1020 Tree Traversals","text":"<p>\u601d\u8def\uff1a\u5229\u7528\u540e\u5e8f\u548c\u4e2d\u5e8f\u8fdb\u884c\u4e8c\u53c9\u6811\u7684\u91cd\u5efa\uff0c\u4e4b\u540e\u7528BFS\u8fdb\u884c\u5c42\u5e8f\u904d\u5386\u6253\u5370 <pre><code>#include&lt;cstdio&gt;\n#include&lt;queue&gt;\nusing namespace std;\n\nconst int maxn = 35;\n\ntypedef struct Node {\n    int data;\n    struct Node* left;\n    struct Node* right;\n} Node;\n\nint inOrder[maxn], postOrder[maxn];\n\nNode* reCreate(int postL, int postR, int inL, int inR) {\n    if(postL &gt; postR) return NULL;\n    Node* root = new Node;\n    root-&gt;data = postOrder[postR];\n    int i;\n    for(i = inL; i &lt;= inR; i++) \n        if(inOrder[i] == postOrder[postR]) break;\n    int numL = i - inL;\n    root-&gt;left = reCreate(postL, postL + numL - 1, inL, i - 1);\n    root-&gt;right = reCreate(postL + numL, postR - 1, i + 1, inR);\n    return root;\n}\n\nint n;\nint num = 0;\nvoid BFS(Node* root) {\n    queue&lt;Node*&gt; q;\n    q.push(root);\n    while(!q.empty()) {\n        Node* temp = q.front();\n        q.pop();\n        printf(\"%d\", temp-&gt;data);\n        num++;\n        if(num &lt; n) printf(\" \");\n        if(temp-&gt;left != NULL) q.push(temp-&gt;left);\n        if(temp-&gt;right != NULL) q.push(temp-&gt;right);\n    }\n}\n\nint main() {\n    scanf(\"%d\", &amp;n);\n    for(int i = 0; i &lt; n; i++) \n        scanf(\"%d\", &amp;postOrder[i]);\n    for(int i = 0; i &lt; n; i++)\n        scanf(\"%d\", &amp;inOrder[i]);\n    Node* root = reCreate(0, n - 1, 0, n - 1);\n    BFS(root);\n    printf(\"\\n\");\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/PAT%20A1086_Tree%20Traversals%20Again/","title":"PAT A1086 Tree Traversals Again","text":"<p>\u601d\u8def\uff1a\u76f4\u63a5\u6a21\u62df\u6808\u7684\u51fa\u6808\u548c\u5165\u6808\uff0c\u9898\u76ee\u4e2d\u6709\u6309\u65f6Push\u64cd\u4f5c\u76f8\u5f53\u4e8e\u5148\u5e8f\u904d\u5386\uff0c\u800cPop\u64cd\u4f5c\u76f8\u5f53\u4e8e\u4e2d\u5e8f\u904d\u5386\u3002\u7531\u5148\u5e8f+\u4e2d\u5e8f\u6216\u540e\u5e8f+\u4e2d\u5e8f\u53ef\u91cd\u6784\u4e8c\u53c9\u6811\uff0c\u5373\u91cd\u5efa\u6811\u5e76\u8fdb\u884c\u540e\u5e8f\u904d\u5386\u3002 <pre><code>#include&lt;cstdio&gt;\n#include&lt;stack&gt;\n#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;string&gt;\nusing namespace std;\n\nstack&lt;int&gt; st;\nint n, num;\nstring action;\nvector&lt;int&gt; pre, in, post;\n\ntypedef struct Node {\n    int val;\n    Node *left, *right;\n} Node;\n\nvoid postOrder(Node *root) {\n    if(root == NULL) return;\n    postOrder(root-&gt;left);\n    postOrder(root-&gt;right);\n    post.push_back(root-&gt;val);\n}\n\nNode* reCreate(int preL, int preR, int inL, int inR) {\n    if(preL &gt; preR) return NULL;\n    Node* root = new Node;\n    root-&gt;val = pre[preL];\n    int k;\n    for(k = inL; k &lt;= inR; k++)\n        if(in[k] == pre[preL])\n            break;\n    int numLeft = k - inL;\n    root-&gt;left = reCreate(preL + 1, preL + numLeft, inL, k - 1);\n    root-&gt;right = reCreate(preL + numLeft + 1, preR, k + 1, inR);\n    return root;\n}\n\nint main() {\n    scanf(\"%d\", &amp;n);\n    for(int i = 0; i &lt; 2 * n; i++) {\n        cin &gt;&gt; action;\n        if(action == \"Push\") {\n            cin &gt;&gt; num;\n            st.push(num);\n            pre.push_back(num);\n        } else if(action == \"Pop\") {\n            num = st.top();\n            st.pop();\n            in.push_back(num);\n        }\n    }\n    Node *root = reCreate(0, n - 1, 0, n - 1);\n    postOrder(root);\n    for(int i = 0; i &lt; n; i++) {\n        printf(\"%d\", post[i]);\n        if(i &lt; n - 1) printf(\" \");\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/PAT%20A1102_Invert%20a%20Binary%20Tree/","title":"PAT A1102 Invert a Binary Tree","text":"<p>\u601d\u8def\uff1a\u8bbe\u7f6e\u6807\u5fd7\u6570\u7ec4notRoot\uff0c\u5c06\u4f5c\u4e3a\u5de6\u53f3\u5b50\u7ed3\u70b9\u90fd\u6392\u9664\u4e3a\u6839\u8282\u70b9\uff0c\u53ef\u627e\u5230\u6839\u8282\u70b9\u3002\u63a5\u7740\u6839\u636e\u540e\u5e8f\u904d\u5386\u7684\u987a\u5e8f\u6765Invert\u6574\u9897\u6811\uff0c\u5229\u7528BFS\u8fdb\u884c\u5c42\u5e8f\u904d\u5386\u3002 <pre><code>#include&lt;cstdio&gt;\n#include&lt;queue&gt;\n#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\nusing namespace std;\n\nconst int maxn = 15;\n\ntypedef struct {\n    int left, right;\n} Node;\n\nNode node[maxn];\nbool notRoot[maxn];\nint n, num;\n\nint ToNumber(char ch) {\n    if(ch == '-') return -1;\n    notRoot[ch - '0'] = true;\n    return ch - '0';\n}\n\nint findRoot() {\n    for(int i = 0; i &lt; n; i++)\n        if(!notRoot[i]) return i;\n    return -1;\n}\n\nvoid invertTree(int root) {\n    if(root == -1) return;\n    invertTree(node[root].left);\n    invertTree(node[root].right);\n    swap(node[root].left, node[root].right);\n}\n\nvoid levelOrder(int root) {\n    queue&lt;int&gt; q;\n    q.push(root);\n    while(!q.empty()) {\n        int temp = q.front();\n        q.pop();\n        printf(\"%d\", temp);\n        num++;\n        if(num &lt; n) printf(\" \");\n        if(node[temp].left != -1) q.push(node[temp].left);\n        if(node[temp].right != -1) q.push(node[temp].right);\n    }\n    num = 0;\n    printf(\"\\n\");\n}\n\nvoid inOrder(int root) {\n    if(root == -1) return;\n    inOrder(node[root].left);\n    printf(\"%d\", root);\n    num++;\n    if(num &lt; n) printf(\" \");\n    inOrder(node[root].right);\n}\n\nint main() {\n    cin &gt;&gt; n;\n    char left, right;\n    for(int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; left &gt;&gt; right;\n        node[i].left = ToNumber(left);\n        node[i].right = ToNumber(right);\n    }\n    int root = findRoot();\n    invertTree(root);\n    levelOrder(root);\n    inOrder(root);\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A0%91/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/PAT%20A1066_Root%20of%20AVL%20Tree/","title":"PAT A1066 Root of AVL Tree","text":"<p>\u601d\u8def\uff1a\u5e73\u8861\u4e8c\u53c9\u6811\u7684\u6a21\u677f\u9898\u76ee\uff0c\u6ce8\u610fAVL\u6811\u6bcf\u6b21\u63d2\u5165\u540e\u90fd\u8981\u8c03\u6574\u9ad8\u5ea6\uff0c\u7136\u540e\u8fdb\u884c\u76f8\u5e94\u7684\u5de6\u65cb\u548c\u53f3\u65cb <pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\ntypedef struct Node {\n    int data, height;\n    struct Node* left, * right;\n} Node;\n\nint n;\n\nNode* createNode(int val) {\n    Node* node = new Node;\n    node-&gt;data = val;\n    node-&gt;height = 1;\n    node-&gt;left = node-&gt;right = NULL;\n    return node;\n}\n\nint getHeight(Node* root) {\n    if(root == NULL) return 0;\n    return root-&gt;height;\n}\n\nvoid updateHeight(Node* root) {\n    root-&gt;height = max(getHeight(root-&gt;left), getHeight(root-&gt;right)) + 1;\n}\n\n// \u8fd9\u91cc\u5b9a\u4e49\u5e73\u8861\u56e0\u5b50\u6570\u503c\u4e3a\u5de6\u5b50\u6811\u4e0e\u53f3\u5b50\u6811\u7684\u9ad8\u5ea6\u5dee\nint getBalanceFactor(Node* root) {\n    return getHeight(root-&gt;left) - getHeight(root-&gt;right);\n}\n\nvoid leftRotation(Node* &amp;root) {\n    Node* temp = root-&gt;right;\n    root-&gt;right = temp-&gt;left;\n    temp-&gt;left = root;\n    updateHeight(root);\n    updateHeight(temp);\n    root = temp;\n}\n\nvoid rightRotation(Node* &amp;root) {\n    Node* temp = root-&gt;left;\n    root-&gt;left = temp-&gt;right;\n    temp-&gt;right = root;\n    updateHeight(root);\n    updateHeight(temp);\n    root = temp;\n}\n\nvoid insert(Node* &amp;root, int val) {\n    if(root == NULL) {\n        root = createNode(val);\n        return;\n    }\n    if(root-&gt;data &lt; val) {\n        insert(root-&gt;right, val);\n        updateHeight(root);\n        if(getBalanceFactor(root) == -2) {\n            // RR\n            if(getBalanceFactor(root-&gt;right) == -1) {\n                leftRotation(root);\n            // RL\n            } else if(getBalanceFactor(root-&gt;right) == 1) {\n                rightRotation(root-&gt;right);\n                leftRotation(root);\n            }\n        } \n    } else {\n        insert(root-&gt;left, val);\n        updateHeight(root);\n        if(getBalanceFactor(root) == 2) {\n            // LL\n            if(getBalanceFactor(root-&gt;left) == 1) {\n                rightRotation(root);\n            // LR\n            } else if(getBalanceFactor(root-&gt;left) == -1) {\n                leftRotation(root-&gt;left);\n                rightRotation(root);\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &amp;n);\n    int val;\n    Node* root = NULL;\n    for(int i = 0; i &lt; n; i++) {\n        scanf(\"%d\", &amp;val);\n        insert(root, val);\n    }\n    printf(\"%d\", root-&gt;data);\n    return 0;\n} \n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A0%91/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/PAT%20A1004_Counting%20Leaves/","title":"PAT A1004 Counting Leaves","text":"<p>\u601d\u8def\uff1avector\u5efa\u6811\uff0cDFS\u904d\u5386\u7ed3\u70b9\uff0c\u901a\u8fc7\u66f4\u65b0\u6700\u5927\u9ad8\u5ea6\u6765\u786e\u5b9a\u6709\u591a\u5c11\u5c42\u3002\u5e76\u4e14\u7528\u6570\u7ec4\u6765\u8bb0\u5f55\u6bcf\u4e00\u5c42\u7684\u53f6\u5b50\u7ed3\u70b9\u3002 <pre><code>#include&lt;cstdio&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nconst int maxn = 105;\n\nvector&lt;int&gt; children[maxn];\nint N, M, maxDepth;\nint res[maxn];\n\nvoid DFS(int idx, int depth) {\n    int child_num = children[idx].size();\n    if(child_num == 0) {\n        res[depth]++;\n        if(depth &gt; maxDepth) {\n            maxDepth = depth;\n        }\n        return;\n    }\n    for(int i = 0; i &lt; child_num; i++) \n        DFS(children[idx][i], depth + 1);\n}\n\nint main() {\n    scanf(\"%d %d\", &amp;N, &amp;M);\n    int father, num, child;\n    for(int i = 0; i &lt; M; i++) {\n        scanf(\"%d %d\", &amp;father, &amp;num);\n        for(int j = 0; j &lt; num; j++) {\n            scanf(\"%d\", &amp;child);\n            children[father].push_back(child);\n        }\n    }\n    DFS(1, 0);\n    for(int i = 0; i &lt;= maxDepth; i++) {\n        printf(\"%d\", res[i]);\n        if(i &lt; maxDepth) printf(\" \");\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A0%91/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/PAT%20A1053_Path%20of%20Equal%20Weight/","title":"PAT A1053 Path of Equal Weight","text":"<p>\u601d\u8def\uff1a\u5229\u7528\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u5bf9\u8def\u5f84\u8fdb\u884c\u641c\u7d22\uff0c\u6ce8\u610f\u5224\u65ad\u662f\u5426\u5230\u8fbe\u53f6\u7ed3\u70b9\u4ee5\u53ca\u526a\u679d\u3002\u6ce8\u610f\uff0c\u9898\u76ee\u4e2d\u6700\u540e\u4e00\u4e2a\u6d4b\u8bd5\u70b9\u53ef\u80fd\u51fa\u73b0\u5b50\u7ed3\u70b9\u503c\u4e71\u5e8f\u3002\u5373\u7b97\u6cd5\u7b14\u8bb0\u4e2d\u7684\u53c2\u8003\u7b54\u6848\u8fdb\u884c\u7684\u6392\u5e8f\u6392\u5e8f\u53ea\u80fd\u4fdd\u8bc1\u6bcf\u4e2a\u7ed3\u70b9\u7684\u76f4\u63a5\u5b50\u7ed3\u70b9\u4fdd\u6301\u6709\u5e8f\uff0c\u4f46\u662f\u65e0\u6cd5\u4fdd\u8bc1\u952e\u503c\u76f8\u540c\u7684\u5b50\u7ed3\u70b9\u7684\u5b50\u7ed3\u70b9\uff0c\u5373\u5b59\u7ed3\u70b9\u6709\u5e8f\u3002 \u6bd4\u5982\u8f93\u51fa\u5e8f\u5217 10 9 8 7 \u548c 10 9 7 8\uff0c\u6545\u9700\u8981\u628a\u6240\u6709\u7684\u7b54\u6848\u5e8f\u5217\u8fdb\u884c\u518d\u6b21\u6392\u5e8f\uff0c\u6ce8\u610f\u5934\u6587\u4ef6\u5305\u542b\u4e86greater\u51fd\u6570\u6a21\u677f\u3002 <pre><code>#include&lt;cstdio&gt;\n#include&lt;vector&gt;\n#include&lt;algorithm&gt;\n#include&lt;functional&gt;\nusing namespace std;\n\nconst int maxn = 105;\n\ntypedef struct Node Node;\nstruct Node {\n    int data;\n    vector&lt;int&gt; children;\n};\n\nNode node[maxn];\n\nbool cmp(int a, int b) {\n    return node[a].data &gt; node[b].data;\n}\n\nint n, m, target;\n\nint path[maxn];\nvector&lt;vector&lt;int&gt;&gt; ans;\n\nvoid DFS(int idx, int num, int sum) {\n    if(sum &gt; target) return;\n    if(sum == target) {\n        if(node[idx].children.size() != 0) return;\n        vector&lt;int&gt; res;\n        for(int i = 0; i &lt; num; i++) {\n            res.push_back(node[path[i]].data);\n        }\n        ans.push_back(res);\n        return;\n    }\n    for(int i = 0; i &lt; node[idx].children.size(); i++) {\n        int child = node[idx].children[i];\n        path[num] = child;\n        DFS(child, num + 1, sum + node[child].data);\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &amp;n, &amp;m, &amp;target);\n    for(int i = 0; i &lt; n; i++) {\n        scanf(\"%d\", &amp;node[i].data);\n    }\n    int idx, size, child;\n    for(int i = 0; i &lt; m; i++) {\n        scanf(\"%d %d\", &amp;idx, &amp;size);\n        for(int j = 0; j &lt; size; j++) {\n            scanf(\"%d\", &amp;child);\n            node[idx].children.push_back(child);\n        }\n        sort(node[idx].children.begin(), node[idx].children.end(), cmp);\n    }\n    path[0] = 0;\n    DFS(0, 1, node[0].data);\n    sort(ans.begin(), ans.end(), greater&lt;vector&lt;int&gt;&gt;());\n    for(auto &amp;res : ans) {\n        for(int i = 0; i &lt; res.size(); i++) {\n            printf(\"%d\", res[i]);\n            if(i &lt; res.size() - 1)\n                printf(\" \");\n            else printf(\"\\n\");\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A0%91/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/PAT%20A1079_Total%20Sales%20of%20Supply%20Chain/","title":"PAT A1079 Total Sales of Supply Chain","text":"<p>\u601d\u8def\uff1a\u672c\u9898\u4e0eA1090\u76f8\u4f3c\uff0cvector\u5efa\u6811\u7136\u540e\u4f7f\u7528DFS\uff0c\u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u53f6\u7ed3\u70b9\u591a\u4e86\u70b9\u6743\u3002 <pre><code>#include&lt;cstdio&gt;\n#include&lt;vector&gt;\n#include&lt;cmath&gt;\nusing namespace std;\n\nconst int maxn = 100005;\n\ntypedef struct {\n    double val;\n    vector&lt;int&gt; children;\n} Node;\n\nNode node[maxn];\n\nint n;\ndouble p, r, res;\n\nvoid DFS(int idx, int depth) {\n    int child_num = node[idx].children.size();\n    if(child_num == 0) {\n        res += node[idx].val * pow(1 + r, depth);\n        return;\n    }\n    for(int i = 0; i &lt; child_num; i++) \n        DFS(node[idx].children[i], depth + 1);\n}\n\nint main() {\n    scanf(\"%d %lf %lf\", &amp;n, &amp;p, &amp;r);\n    r /= 100;\n    int num, child;\n    for(int i = 0; i &lt; n; i++) {\n        scanf(\"%d\", &amp;num);\n        if(num) {\n            for(int j = 0; j &lt; num; j++) {\n                scanf(\"%d\", &amp;child);\n                node[i].children.push_back(child);\n            }\n        } else {\n            scanf(\"%lf\", &amp;node[i].val);\n        }\n    }\n    // \u6ce8\u610f\u6839\u7ed3\u70b9\u5df2\u7ecf\u8bf4\u660e\u662f0\n    DFS(0, 0);\n    printf(\"%.1f\", p * res);\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A0%91/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/PAT%20A1090_Highest%20Price%20in%20Supply%20Chain/","title":"PAT A1090 Highest Price in Supply Chain","text":"<p>\u601d\u8def\uff1a\u6839\u636e\u8f93\u5165\u5efa\u7acbvector\u4e3a\u7ed3\u6784\u7684\u6811\uff0c\u518d\u901a\u8fc7DFS\u6c42\u5f97\u6700\u5927\u9ad8\u5ea6\uff0c\u5373\u53ef\u89e3\u51b3 <pre><code>#include&lt;cstdio&gt;\n#include&lt;cmath&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nconst int maxn = 100005;\n\nint n, maxDepth, num, father, root;\ndouble p, r;\nvector&lt;int&gt; children[maxn];\n\nvoid DFS(int idx, int depth) {\n    int children_num = children[idx].size();\n    if(children_num == 0) {\n        if(depth &gt; maxDepth) {\n            maxDepth = depth;\n            num = 1;\n        } else if(depth == maxDepth) {\n            num++;\n        }\n        return;\n    }\n    for(int i = 0; i &lt; children_num; i++)\n        DFS(children[idx][i], depth + 1);\n}\n\nint main() {\n    scanf(\"%d %lf %lf\", &amp;n, &amp;p, &amp;r);\n    for(int i = 0; i &lt; n; i++) {\n        scanf(\"%d\", &amp;father);\n        if(father != -1) {\n            children[father].push_back(i);\n        } else {\n            root = i;\n        }\n    }\n    DFS(root, 0);\n    r /= 100;\n    printf(\"%.2f %d\", p * pow(1 + r, maxDepth), num);\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A0%91/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/PAT%20A1094_The%20Largest%20Generation/","title":"PAT A1094 The Largest Generation","text":"<p>\u601d\u8def\uff1a\u5229\u7528vector\u5efa\u6811\uff0c\u7528\u6570\u7ec4\u7edf\u8ba1\u6bcf\u4e00\u5c42\u7684\u7ed3\u70b9\u6570\u91cf\uff0c\u901a\u8fc7DFS\u6765\u904d\u5386\u6240\u6709\u7ed3\u70b9\u5373\u53ef <pre><code>#include&lt;cstdio&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nconst int maxn = 100;\nvector&lt;int&gt; children[maxn];\nint levelTable[maxn];\nint N, M;\n\nvoid DFS(int idx, int level) {\n    levelTable[level]++;\n    int child_num = children[idx].size();\n    if(child_num == 0) return;\n    for(int i = 0; i &lt; child_num; i++) \n        DFS(children[idx][i], level + 1);\n}\n\nint main() {\n    scanf(\"%d %d\", &amp;N, &amp;M);\n    int num, child, father;\n    for(int i = 0; i &lt; M; i++) {\n        scanf(\"%d %d\", &amp;father, &amp;num);\n        for(int j = 0; j &lt; num; j++) {\n            scanf(\"%d\", &amp;child);\n            children[father].push_back(child);\n        }\n    }\n    //\u6839\u7ed3\u70b9\u4e3a1\uff0clevel\u8d77\u59cb\u4e3a1\n    DFS(1, 1);\n    int maxLevel = 0;\n    for(int i = 1; i &lt;= N; i++) \n        if(levelTable[i] &gt; levelTable[maxLevel])\n            maxLevel = i;\n    printf(\"%d %d\", levelTable[maxLevel], maxLevel);\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A0%91/%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/PAT%20A1106_Lowest%20Price%20in%20Supply%20Chain/","title":"PAT A1106 Lowest Price in Supply Chain","text":"<p>\u601d\u8def\uff1a\u6839\u636e\u8f93\u5165\u5efa\u7acbvector\u4e3a\u7ed3\u6784\u7684\u6811\uff0c\u518d\u901a\u8fc7DFS\u6c42\u5f97\u6700\u5c0f\u9ad8\u5ea6\uff0c\u540c\u65f6\u8bb0\u5f55\u6700\u5c0f\u9ad8\u5ea6\u7ed3\u70b9\u7684\u6570\u91cf\uff0c\u5373\u53ef\u89e3\u51b3 <pre><code>#include&lt;cstdio&gt;\n#include&lt;vector&gt;\n#include&lt;cmath&gt;\nusing namespace std;\n\nconst int maxn = 100005;\n\nvector&lt;int&gt; children[maxn];\ndouble p, r;\nint n, minDepth = maxn, cnt;\n\nvoid DFS(int idx, int depth) {\n    int child_num = children[idx].size();\n    if(child_num == 0) {\n        if(depth &lt; minDepth) {\n            minDepth = depth;\n            cnt = 1;\n        }\n        else if(depth == minDepth) cnt++;\n        return;\n    }\n    for(int i = 0; i &lt; child_num; i++)\n        DFS(children[idx][i], depth + 1);\n}\n\nint main() {\n    scanf(\"%d %lf %lf\", &amp;n, &amp;p, &amp;r);\n    r /= 100;\n    int num, child;\n    for(int i = 0; i &lt; n; i++) {\n        scanf(\"%d\", &amp;num);\n        for(int j = 0; j &lt; num; j++) {\n            scanf(\"%d\", &amp;child);\n            children[i].push_back(child);\n        }\n    }\n    DFS(0, 0);\n    printf(\"%.4f %d\", p * pow(1 + r, minDepth), cnt);\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A8%A1%E6%8B%9F/PAT%20A1001_A%2BB%20Format/","title":"PAT A1001 A+B Format","text":"<p>\u601d\u8def\uff1a\u5148\u8fdb\u884c\u7b26\u53f7\u5904\u7406\uff0c\u518d\u8ba1\u7b97\u9664 3 \u7ed3\u679c cnt \u548c\u6a21 3 \u7684\u4f59\u6570 remain\uff0c\u6839\u636e cnt \u548c remain \u7684\u4e0d\u540c\u6765\u5904\u7406\uff0c\u5316\u7b80\u6210\u500d\u6570\u4e3a 3 \u7684\u5b50\u4e32\u95ee\u9898\u3002</p> <pre><code>#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\n\nint main() {\n    int a, b, sum;\n    cin &gt;&gt; a &gt;&gt; b;\n    sum = a + b;\n    if(sum &lt; 0) {\n        sum = -sum;\n        cout &lt;&lt; \"-\";\n    }\n    string s = to_string(sum);\n    int cnt = s.size() / 3, remain = s.size() % 3;\n    if(cnt == 0) {\n        cout &lt;&lt; s;\n        return 0;\n    }\n    if(remain == 1) {\n        cout &lt;&lt; s[0] &lt;&lt; \",\";\n        s = s.substr(1);\n    }\n    if(remain == 2) {\n        cout &lt;&lt; s[0] &lt;&lt; s[1] &lt;&lt; \",\";\n        s = s.substr(2);\n    }\n    cnt--;\n    for(int i = 0; i &lt; s.size(); i++) {\n        if(cnt &gt; 0 &amp;&amp; i &gt; 0 &amp;&amp; i % 3 == 0) {\n            cout &lt;&lt; \",\";\n            cnt--;\n        }\n        cout &lt;&lt; s[i];\n    }\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A8%A1%E6%8B%9F/PAT%20A1002_A%2BB%20for%20Polynomials/","title":"PAT A1002 A+B for Polynomials","text":"<p>\u601d\u8def\uff1a\u6574\u4f53\u601d\u8def\u7c7b\u4f3c\u4e8e\u5f52\u5e76\u6392\u5e8f\uff0c\u5c06\u8f93\u5165\u6570\u636e\u5c01\u88c5\u6210\u7ed3\u6784\u540e\u6309\u6307\u6570\u5927\u5c0f\u6392\u5e8f\uff0c\u91c7\u7528\u961f\u5217\u7684\u505a\u6cd5\u3002\u6ce8\u610f\u7cfb\u6570\u76f8\u52a0\u540e\u82e5\u4e3a 0\uff0c\u8be5\u9879\u4e0d\u5b58\u5728\uff0c\u4e0d\u80fd\u52a0\u5165\u7b54\u6848\u3002 <pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;queue&gt;\nusing namespace std;\n\ntypedef struct {\n    int exp;\n    double coef;\n} Term;\n\nint main() {\n    queue&lt;Term&gt; A, B;\n    int k, e;\n    double c;\n    Term temp;\n    cin &gt;&gt; k;\n    for(int i = 0; i &lt; k; i++) {\n        cin &gt;&gt; e &gt;&gt; c;\n        temp.exp = e;\n        temp.coef = c;\n        A.push(temp);\n    }\n    cin &gt;&gt; k;\n    for(int i = 0; i &lt; k; i++) {\n        cin &gt;&gt; e &gt;&gt; c;\n        temp.exp = e;\n        temp.coef = c;\n        B.push(temp);\n    }\n    vector&lt;Term&gt; ans;\n    Term a, b;\n    while(!A.empty() &amp;&amp; !B.empty()) {\n        a = A.front();\n        b = B.front();\n        if(a.exp == b.exp) {\n            temp.exp = a.exp;\n            temp.coef = a.coef + b.coef;\n            if(temp.coef != 0) ans.push_back(temp);\n            A.pop();\n            B.pop();\n        } else if(a.exp &gt; b.exp) {\n            ans.push_back(a);\n            A.pop();\n        } else {\n            ans.push_back(b);\n            B.pop();\n        }\n    }\n    while(!A.empty()) {\n        a = A.front();\n        ans.push_back(a);\n        A.pop();\n    }\n    while(!B.empty()) {\n        b = B.front();\n        ans.push_back(b);\n        B.pop();\n    }\n    int lens = ans.size();\n    cout &lt;&lt; lens;\n    for(int i = 0; i &lt; lens; i++) {\n        printf(\" %d %.1f\", ans[i].exp, ans[i].coef);\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A8%A1%E6%8B%9F/PAT%20A1006_Sign%20In%20and%20Sign%20Out/","title":"PAT A1006 Sign In and Sign Out","text":"<p>\u601d\u8def\uff1a\u5c06\u8f93\u5165\u7684\u6570\u636e\u5c01\u88c5\u6210\u65b0\u7ed3\u6784\uff0c\u5e76\u4e14\u5904\u7406\u8f93\u5165\u7684\u65f6\u95f4\u5b57\u7b26\u4e32\u4e3a\u4ee5\u79d2\u4e3a\u5355\u4f4d\u7684\u6574\u578b\uff0c\u901a\u8fc7\u4e24\u6b21\u6392\u5e8f\u6765\u786e\u5b9a\u6700\u65e9\u548c\u6700\u665a\u7684\u4eba\u3002</p> <pre><code>#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\ntypedef struct {\n    string id;\n    int inSec, outSec;\n} Info;\n\nvector&lt;Info&gt; res;\n\nbool cmp_in(Info a, Info b) {\n    return a.inSec &lt; b.inSec;\n}\n\nbool cmp_out(Info a, Info b) {\n    return a.outSec &gt; b.outSec;\n}\n\nint strToInt(string s) {\n    int h, m, sec;\n    h = (s[0] - '0') * 10 + (s[1] - '0');\n    m = (s[3] - '0') * 10 + (s[4] - '0');\n    sec = (s[6] - '0') * 10 + (s[7] - '0');\n    sec += h * 60 * 60 + m * 60;\n    return sec;\n}\n\nint main() {\n    int M;\n    string inTime, outTime, id;\n    cin &gt;&gt; M;\n    Info temp;\n    for(int i = 0; i &lt; M; i++) {\n        cin &gt;&gt; id &gt;&gt; inTime &gt;&gt; outTime;\n        temp.id = id;\n        temp.inSec = strToInt(inTime);\n        temp.outSec = strToInt(outTime);\n        res.push_back(temp);\n    }\n    sort(res.begin(), res.end(), cmp_in);\n    cout &lt;&lt; res[0].id &lt;&lt; \" \";\n    sort(res.begin(), res.end(), cmp_out);\n    cout &lt;&lt; res[0].id &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A8%A1%E6%8B%9F/PAT%20A1008_Elevator/","title":"PAT A1008 Elevator","text":"<p>\u601d\u8def\uff1a\u76f4\u63a5\u6309\u987a\u5e8f\u6a21\u62df\u7535\u68af\u8fd0\u884c\uff0c\u6ce8\u610f\u6700\u540e\u4e00\u6b21\u4e5f\u9700\u8981\u505c\u9760 5 \u79d2\u3002 <pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int n, now = 0, next, ans = 0;\n    cin &gt;&gt; n;\n    for(int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; next;\n        if(next &gt; now) ans += (next - now) * 6;\n        else ans += (now - next) * 4;\n        now = next;\n        ans += 5;\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A8%A1%E6%8B%9F/PAT%20A1009_Product%20of%20Polynomials/","title":"PAT A1009 Product of Polynomials","text":"<p>\u601d\u8def\uff1a\u5148\u5c06\u591a\u9879\u5f0f A \u8f93\u5165\u5e76\u5c01\u88c5\u5230 vector \u4e2d\uff0c\u518d\u5f00\u8bbe\u4e00\u4e2a\u5927\u5c0f\u4e3a 2000 \u7684\u6570\u7ec4 ans \u6765\u8bb0\u5f55\u7b54\u6848\uff0cans[i] \u4ee3\u8868 coef\uff0ci \u4ee3\u8868 exp\u3002 <pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\ntypedef struct {\n    int exp;\n    double coef;\n} Poly;\n\ndouble ans[2005];\nvector&lt;Poly&gt; p;\n\nint main() {\n    int k, exp;\n    double coef;\n    cin &gt;&gt; k;\n    Poly temp;\n    for(int i = 0; i &lt; k; i++) {\n        cin &gt;&gt; exp &gt;&gt; coef;\n        temp.exp = exp;\n        temp.coef = coef;\n        p.push_back(temp);\n    }\n    cin &gt;&gt; k;\n    for(int i = 0; i &lt; k; i++) {\n        cin &gt;&gt; exp &gt;&gt; coef;\n        for(int j = 0; j &lt; p.size(); j++) {\n            ans[exp + p[j].exp] += coef * p[j].coef;\n        }\n    }\n    int num = 0;\n    for(int i = 0; i &lt;= 2000; i++)\n        if(ans[i] != 0.0) num++;\n    cout &lt;&lt; num;\n    for(int i = 2000; i &gt;= 0; i--)\n        if(ans[i] != 0.0)\n            printf(\" %d %.1f\", i, ans[i]);\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A8%A1%E6%8B%9F/PAT%20A1011_World%20Cup%20Betting/","title":"PAT A1011 World Cup Betting","text":"<p>\u601d\u8def\uff1a\u76f4\u63a5\u8fdb\u884c\u7b80\u5355\u7684\u53d6\u6700\u5927\u503c\u4e58\u79ef\u6a21\u62df\u3002</p> <pre><code>#include&lt;iostream&gt;\n#include&lt;cstdio&gt;\nusing namespace std;\n\nchar mp[3] = {'W', 'T', 'L'};\n\nint main() {\n    double ans = 1.0, temp, a;\n    int idx;\n    for(int i = 0; i &lt; 3; i++) {\n        temp = 0.0;\n        for(int j = 0; j &lt; 3; j++) {\n            cin &gt;&gt; a;\n            if(a &gt; temp) {\n                temp = a;\n                idx = j;\n            }\n        }\n        ans *= temp;\n        printf(\"%c \", mp[idx]);\n    }\n    printf(\"%.2f\", (ans * 0.65 - 1) * 2);\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A8%A1%E6%8B%9F/PAT%20A1019_General%20Palindromic%20Number/","title":"PAT A1019 General Palindromic Number","text":"<p>\u601d\u8def\uff1a\u7b80\u5355\u7684\u56de\u6587\u6a21\u62df\u5224\u65ad\uff0c\u6ce8\u610f\u5f53 N = 0 \u65f6\u76f4\u63a5\u5224\u65ad\u4e3a\u56de\u6587\u6570\u3002</p> <pre><code>#include&lt;iostream&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nvector&lt;int&gt; res;\n\nvoid GetDigits(int N, int b) {\n    while(N != 0) {\n        res.push_back(N % b);\n        N /= b;\n    }\n}\n\nbool JudgePalin() {\n    int lens = res.size();\n    for(int i = 0; i &lt; lens / 2; i++) {\n        if(res[i] != res[lens - i - 1])\n            return false;\n    }\n    return true;\n}\n\nint main() {\n    int N, b;\n    cin &gt;&gt; N &gt;&gt; b;\n    if(N == 0) {\n        cout &lt;&lt; \"Yes\" &lt;&lt; endl;\n        cout &lt;&lt; \"0\";\n        return 0;\n    }\n    GetDigits(N, b);\n    if(JudgePalin() == true) cout &lt;&lt; \"Yes\" &lt;&lt; endl;\n    else cout &lt;&lt; \"No\" &lt;&lt; endl;\n    for(int i = res.size() - 1; i &gt;= 0; i--) {\n        cout &lt;&lt; res[i];\n        if(i != 0) cout &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A8%A1%E6%8B%9F/PAT%20A1027_Colors%20in%20Mars/","title":"PAT A1027 Colors in Mars","text":"<p>\u601d\u8def\uff1a\u7b80\u5355\u7684\u8fdb\u5236\u8f6c\u6362\u6a21\u62df\uff0c\u4f7f\u7528\u6570\u7ec4\u66f4\u52a0\u5feb\u6377\u3002</p> <pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nchar mp[13] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C'};\nint a[3];\n\nint main() {\n    cin &gt;&gt; a[0] &gt;&gt; a[1] &gt;&gt; a[2];\n    cout &lt;&lt; \"#\";\n    for(int i = 0; i &lt; 3; i++) {\n        cout &lt;&lt; mp[a[i] / 13] &lt;&lt; mp[a[i] % 13];\n    }\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A8%A1%E6%8B%9F/PAT%20A1031_Hello%20World%20for%20U/","title":"PAT A1031 Hello World for U","text":"<p>\u601d\u8def\uff1a\u4f7f\u7528\u4e8c\u7ef4\u6570\u7ec4\u8fdb\u884c\u6a21\u62df\uff0c\u6ce8\u610f n1 + n2 + n3 = N + 2\uff0c\u5176\u4e2d 2 \u7684\u542b\u4e49\u662f n1 \u548c n3 \u4e0e n2 \u5728\u5de6\u4e0b\u89d2\u548c\u53f3\u4e0b\u89d2\u5b58\u5728\u91cd\u5408\u3002</p> <pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    char ans[40][40];\n    string s;\n    cin &gt;&gt; s;\n    int k = (s.size() + 2) / 3;\n    int n2 = s.size() + 2 - 2 * k;\n    for(int i = 0; i &lt; 40; i++)\n        for(int j = 0; j &lt; 40; j++)\n            ans[i][j] = ' ';\n    int pos = 0;\n    for(int i = 0; i &lt; k; i++)\n        ans[i][0] = s[pos++];\n    for(int i = 1; i &lt; n2; i++)\n        ans[k-1][i] = s[pos++];\n    for(int i = k - 2; i &gt;= 0; i--)\n        ans[i][n2-1] = s[pos++];\n    for(int i = 0; i &lt; k; i++) {\n        for(int j = 0; j &lt; n2; j++)\n            cout &lt;&lt; ans[i][j];\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A8%A1%E6%8B%9F/PAT%20A1035_Password/","title":"PAT A1035 Password","text":"<p>\u601d\u8def\uff1a\u76f4\u63a5\u8fdb\u884c\u7b80\u5355\u7684\u5b57\u7b26\u4e32\u6a21\u62df\u66ff\u6362\u5373\u53ef\u3002 <pre><code>#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\ntypedef struct {\n    string id, passwd;\n} Info;\n\nvector&lt;Info&gt; ans;\n\nvoid proc_passwd(Info a) {\n    bool isChanged = false;\n    for(int i = 0; i &lt; a.passwd.size(); i++) {\n        if(a.passwd[i] == '1') { \n            a.passwd[i] = '@';\n            isChanged = true;\n        }\n        else if(a.passwd[i] == '0') { \n            a.passwd[i] = '%';\n            isChanged = true;\n        }\n        else if(a.passwd[i] == 'l') {\n            a.passwd[i] = 'L';\n            isChanged = true;\n        }\n        else if(a.passwd[i] == 'O') {\n            a.passwd[i] = 'o';\n            isChanged = true;\n        }\n    }\n    if(isChanged) ans.push_back(a);\n}\n\nint main() {\n    int N;\n    cin &gt;&gt; N;\n    Info temp;\n    for(int i = 0; i &lt; N; i++) {\n        cin &gt;&gt; temp.id &gt;&gt; temp.passwd;\n        proc_passwd(temp);\n    }\n    if(ans.size() == 0) {\n        if(N == 1) cout &lt;&lt; \"There is 1 account and no account is modified\";\n        else cout &lt;&lt; \"There are \" &lt;&lt; N &lt;&lt; \" accounts and no account is modified\";\n    } else {\n        cout &lt;&lt; ans.size() &lt;&lt; endl;\n        for(auto &amp;a : ans) {\n            cout &lt;&lt; a.id &lt;&lt; \" \" &lt;&lt; a.passwd &lt;&lt; endl;\n        }\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A8%A1%E6%8B%9F/PAT%20A1036_Boys%20vs%20Girls/","title":"PAT A1036 Boys vs Girls","text":"<p>\u601d\u8def\uff1a\u7b80\u5355\u7684\u8f93\u5165\u5c01\u88c5\u7ed3\u6784\u6a21\u62df\u3002</p> <pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\ntypedef struct {\n    string name, id;\n    int score;\n} Student;\n\nStudent m, f, temp;\nint n;\n\nvoid init() {\n    m.score = 101;\n    f.score = -1;\n}\n\nint main() {\n    init();\n    cin &gt;&gt; n;\n    char gender;\n    for(int i = 0; i &lt; n; i++) {\n        cin &gt;&gt; temp.name &gt;&gt; gender &gt;&gt; temp.id &gt;&gt; temp.score;\n        if(gender == 'M' &amp;&amp; temp.score &lt; m.score) \n            m = temp;\n        else if(gender == 'F' &amp;&amp; temp.score &gt; f.score)\n            f = temp;\n    }\n    if(f.score == -1) cout &lt;&lt; \"Absent\" &lt;&lt; endl;\n    else cout &lt;&lt; f.name &lt;&lt; \" \" &lt;&lt; f.id &lt;&lt; endl;\n    if(m.score == 101) cout &lt;&lt; \"Absent\" &lt;&lt; endl;\n    else cout &lt;&lt; m.name &lt;&lt; \" \" &lt;&lt; m.id &lt;&lt; endl;\n    if(f.score == -1 || m.score == 101) cout &lt;&lt; \"NA\";\n    else cout &lt;&lt; f.score - m.score;\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A8%A1%E6%8B%9F/PAT%20A1042_Shuffing%20Machine/","title":"PAT A1042 Shuffing Machine","text":"<p>\u601d\u8def\uff1a\u6309\u7167\u9898\u76ee\u610f\u601d\u8fdb\u884c\u6a21\u62df\u5373\u53ef\uff0c\u6ce8\u610f iostream \u5934\u6587\u4ef6\u4e2d\u5df2\u7ecf\u6709 next \u7684\u547d\u540d\uff0c\u53ef\u80fd\u51fa\u73b0\u62a5\u9519\u3002</p> <pre><code>#include&lt;cstdio&gt;\nusing namespace std;\n\nconst int N = 54;\n\nchar numToLet[5] = {'S', 'H', 'C', 'D', 'J'};\nint start[60], end[60], next[60];\nint k;\n\nint main() {\n    scanf(\"%d\", &amp;k);\n    for(int i = 1; i &lt;= N; i++) {\n        start[i] = i;\n        scanf(\"%d\", &amp;next[i]);\n    }\n    for(int i = 0; i &lt; k; i++) {\n        for(int j = 1; j &lt;= N; j++) {\n            end[next[j]] = start[j];\n        }\n        for(int j = 1; j &lt;= N; j++) {\n            start[j] = end[j];\n        }\n    }\n    for(int i = 1; i &lt;= N; i++) {\n        printf(\"%c%d\", numToLet[(start[i] - 1) / 13], (start[i] - 1) % 13 + 1);\n        if(i != N) printf(\" \");\n    }\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A8%A1%E6%8B%9F/PAT%20A1046_Shortest%20Distance/","title":"PAT A1046 Shortest Distance","text":"<p>\u601d\u8def\uff1a\u9884\u5904\u7406\u4ece 1 \u53f7\u7ed3\u70b9\u5230 N \u53f7\u8282\u70b9\u7684\u8ddd\u79bb\u4e4b\u548c\uff0c\u53e6\u5916\u4f7f\u7528 dist \u6570\u7ec4\uff0cdist[i - 1] \u4ee3\u8868 1 \u53f7\u7ed3\u70b9\u5230 i \u53f7\u7ed3\u70b9\u7684\u8ddd\u79bb\u3002 \u6545 dist(left, right) (left &lt; right) \u53ef\u4ee5\u8868\u793a\u6210 dist[right - 1] - dist[left - 1]\u3002</p> <pre><code>#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconst int MAXN = 100005;\nint N, M;\nint D[MAXN], dist[MAXN];\n\nint main() {\n    cin &gt;&gt; N;\n    int sum = 0;\n    for(int i = 1; i &lt;= N; i++) {\n        cin &gt;&gt; D[i];\n        sum += D[i];\n        dist[i] = sum;\n    }\n    cin &gt;&gt; M;\n    int left, right, temp;\n    for(int i = 0; i &lt; M; i++) {\n        cin &gt;&gt; left &gt;&gt; right;\n        if(left &gt; right) swap(left, right);\n        temp = dist[right - 1] - dist[left - 1];\n        cout &lt;&lt; min(temp, sum - temp) &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A8%A1%E6%8B%9F/PAT%20A1058_A%2BB%20in%20Hogwarts/","title":"PAT A1058 A+B in Hogwarts","text":"<p>\u601d\u8def\uff1a\u76f4\u63a5\u8fdb\u884c\u5b57\u7b26\u4e32\u6a21\u62df\uff0c\u66b4\u529b\u6c42\u89e3\u7b54\u6848\u3002 <pre><code>#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing namespace std;\n\nint main() {\n    string A, B, C;\n    cin &gt;&gt; A &gt;&gt; B;\n    int G_A = 0, S_A = 0, K_A = 0;\n    int G_B = 0, S_B = 0, K_B = 0;\n    int G_C, S_C, K_C;\n    int cnt = 0;\n    for(int i = 0; i &lt; A.size(); i++) {\n        if(A[i] == '.') cnt++;\n        else if(cnt == 0) G_A = 10 * G_A + A[i] - '0';\n        else if(cnt == 1) S_A = 10 * S_A + A[i] - '0';\n        else if(cnt == 2) K_A = 10 * K_A + A[i] - '0';\n    }\n    cnt = 0;\n    for(int i = 0; i &lt; B.size(); i++) {\n        if(B[i] == '.') cnt++;\n        else if(cnt == 0) G_B = 10 * G_B + B[i] - '0';\n        else if(cnt == 1) S_B = 10 * S_B + B[i] - '0';\n        else if(cnt == 2) K_B = 10 * K_B + B[i] - '0';\n    }\n    G_C = G_A + G_B, S_C = S_A + S_B, K_C = K_A + K_B;\n    S_C += K_C / 29, K_C %= 29;\n    G_C += S_C / 17, S_C %= 17;\n    C = to_string(G_C) + \".\" + to_string(S_C) + \".\" + to_string(K_C);\n    cout &lt;&lt; C;\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A8%A1%E6%8B%9F/PAT%20A1065_A%2BB%20and%20C%20%2864bit%29/","title":"PAT A1065 A+B and C (64bit)","text":"<p>\u601d\u8def\uff1a\u7b80\u5355\u7684\u6ea2\u51fa\u5224\u65ad\u9898\uff0c\u7531\u4e8e A B C \u5747\u5904\u4e8e long long \u7684\u6570\u636e\u8303\u56f4\u5185\u3002</p> <p>\u5982\u679c A + B \u7684\u771f\u503c\u5927\u4e8e long long \u4e0a\u9650\uff0c\u5219 A + B \u7684\u771f\u503c\u4e00\u5b9a\u5927\u4e8e C\uff0c\u6b64\u65f6 A &gt; 0, B &gt; 0, A + B &lt; 0</p> <p>\u5982\u679c A + B \u7684\u771f\u503c\u5c0f\u4e8e long long \u4e0b\u9650\uff0c\u5219 A + B \u7684\u771f\u503c\u4e00\u5b9a\u5c0f\u4e8e C\uff0c\u6b64\u65f6 A &lt; 0, B &lt; 0, A + B &gt; 0 <pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    int T;\n    long long A, B, C, res;\n    bool flag;\n    cin &gt;&gt; T;\n    for(int i = 1; i &lt;= T; i++) {\n        cin &gt;&gt; A &gt;&gt; B &gt;&gt; C;\n        res = A + B;\n        if(A &gt; 0 &amp;&amp; B &gt; 0 &amp;&amp; res &lt; 0) flag = true;\n        else if(A &lt; 0 &amp;&amp; B &lt; 0 &amp;&amp; res &gt; 0) flag = false;\n        else if(res &gt; C) flag = true;\n        else flag = false;\n        cout &lt;&lt; \"Case #\" &lt;&lt; i &lt;&lt; \": \";\n        if(flag) cout &lt;&lt; \"true\";\n        else cout &lt;&lt; \"false\";\n        cout &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A8%A1%E6%8B%9F/PAT%20A1073_Scientific%20Notation/","title":"PAT A1073 Scientific Notation","text":"<p>\u601d\u8def\uff1a\u76f4\u63a5\u8fdb\u884c\u66b4\u529b\u6a21\u62df\uff0c\u6ce8\u610f\u5168\u7a0b\u4f7f\u7528\u5b57\u7b26\u4e32\uff0c\u4f7f\u7528\u6d6e\u70b9\u6570\u6216\u8005\u957f\u6574\u578b\u4f1a\u6ea2\u51fa\u3002</p> <pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    string s;\n    cin &gt;&gt; s;\n    if(s[0] == '-') cout &lt;&lt; \"-\";\n    char first = s[1];\n    int posE = 3;\n    while(s[posE] != 'E') posE++;\n\n    int exp = 0;\n    for(int i = posE + 2; i &lt; s.size(); i++)\n        exp = exp * 10 + s[i] - '0';\n    bool isNeg = (s[posE + 1] == '-');\n    s = s.substr(3, posE - 3);\n\n    if(exp == 0) {\n        cout &lt;&lt; first &lt;&lt; \".\" &lt;&lt; s;\n    } else if(!isNeg) {\n        if(exp &gt;= s.size()) {\n            cout &lt;&lt; first &lt;&lt; s;\n            for(int i = 0; i &lt; exp - s.size(); i++)\n                cout &lt;&lt; \"0\";\n        } else {\n            cout &lt;&lt; first &lt;&lt; s.substr(0, exp) &lt;&lt; \".\" &lt;&lt; s.substr(exp);\n        }\n    } else {\n        cout &lt;&lt; \"0.\";\n        exp--;\n        for(int i = 0; i &lt; exp; i++)\n            cout &lt;&lt; \"0\";\n        cout &lt;&lt; first &lt;&lt; s;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A8%A1%E6%8B%9F/PAT%20A1077_Kuchiguse/","title":"PAT A1077 Kuchiguse","text":"<p>\u601d\u8def\uff1a\u5c06\u8f93\u5165\u7684\u5b57\u7b26\u4e32\u8fdb\u884c\u53cd\u8f6c\uff0c\u5c06\u95ee\u9898\u8f6c\u5316\u4e3a\u6c42\u6700\u957f\u516c\u5171\u524d\u7f00\u5b50\u4e32\u3002\u6ce8\u610f\u4f7f\u7528 getline \u51fd\u6570\u4e4b\u524d\uff0c\u4f7f\u7528 getchar \u51fd\u6570\u6765\u63a5\u6536\u6362\u884c\u7b26\uff0c\u5426\u5219\u8f93\u5165\u4f1a\u5c11\u4e00\u884c\u3002</p> <pre><code>#include&lt;iostream&gt;\n#include&lt;string&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\nusing namespace std;\n\nvector&lt;string&gt; res;\n\nint main() {\n    int N, minLen = 300, ans = 0;\n    cin &gt;&gt; N;\n    getchar();\n    string temp;\n    for(int i = 0; i &lt; N; i++) {\n        getline(cin, temp);\n        reverse(temp.begin(), temp.end());\n        res.push_back(temp);\n        if(temp.size() &lt; minLen) minLen = temp.size();\n    }\n    for(int i = 0; i &lt; minLen; i++) {\n        char ch = res[0][i];\n        bool isSame = true;\n        for(int j = 1; j &lt; N; j++) {\n            if(ch != res[j][i]) {\n                isSame = false;\n                break;\n            }\n        }\n        if(isSame) ans++;\n        else break;\n    }\n    if(ans)\n        for(int i = ans - 1; i &gt;= 0; i--)\n            cout &lt;&lt; res[0][i];\n    else cout &lt;&lt; \"nai\";\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E6%A8%A1%E6%8B%9F/PAT%20A1082_Read%20Number%20in%20Chinese/","title":"PAT A1082 Read Number in Chinese","text":"<p>\u601d\u8def\uff1a\u6ce8\u610f\u4ee5\u56db\u4e2a\u4e3a\u4e00\u8282\uff0c\u5171\u6709\u4e2a\u8282\uff0c\u4e07\u8282\uff0c\u4ebf\u8282\u3002\u6ce8\u610f\u9664\u4e86\u6700\u540e\u4e2a\u4f4d\uff0c\u6bcf\u4e00\u8282\u7684\u672b\u5c3e\u8f93\u51fa\u4e07\u6216\u8005\u4ebf\uff0c\u6b64\u5916\u8981\u6ce8\u610f\u5982\u4f55\u5904\u7406\u4e2d\u95f4\u7684\u96f6\u3002\u5c5e\u4e8e\u6bd4\u8f83\u7ed5\u7684\u6a21\u62df\u9898\u3002</p> <pre><code>#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;string&gt;\nusing namespace std;\n\nvector&lt;string&gt; num = {\"ling\", \"yi\", \"er\", \"san\", \"si\", \"wu\", \"liu\", \"qi\", \"ba\", \"jiu\"};\nvector&lt;string&gt; wei = {\"Shi\", \"Bai\", \"Qian\", \"Wan\", \"Yi\"};\n\nint main() {\n    string s;\n    cin &gt;&gt; s;\n    int left = 0, right = s.size() - 1;\n    if(s[0] == '-') {\n        cout &lt;&lt; \"Fu\";\n        left++;\n    }\n    while(left + 4 &lt;= right) right -= 4;\n    while(left &lt; s.size()) {\n        bool flag = false;\n        bool isPrint = false;\n        while(left &lt;= right) {\n            if(left &gt; 0 &amp;&amp; s[left] == '0') {\n                flag = true;\n            } else {\n                if(flag) {\n                    cout &lt;&lt; \" ling\";\n                    flag = false;\n                }\n                if(left &gt; 0) cout &lt;&lt; \" \";\n                cout &lt;&lt; num[s[left] - '0'];\n                // \u8be5\u8282\u4e2d\u81f3\u5c11\u8f93\u51fa\u4e00\u4f4d\u624d\u53ef\u80fd\u8f93\u51fa\u4e07\u6216\u4ebf\n                isPrint = true; \n                // \u67d0\u8282\u4e2d\u9664\u4e86\u4e2a\u4f4d\uff0c\u90fd\u8981\u8f93\u51fa\u5341\u767e\u5343\n                if(left != right) cout &lt;&lt; \" \" &lt;&lt; wei[right - left - 1];\n            }\n            left++;\n        }\n        // \u53ea\u8981\u4e0d\u662f\u4e2a\u4f4d\uff0c\u5c31\u8f93\u51fa\u4e07\u6216\u8005\u4ebf\n        if(isPrint &amp;&amp; right != s.size() - 1) \n            cout &lt;&lt; \" \" &lt;&lt; wei[(s.size() - 1 - right) / 4 + 2];\n        right += 4;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E8%B4%A8%E6%95%B0/PAT%20A1059_Prime%20Factors/","title":"PAT A1059 Prime Factors","text":"<p>\u601d\u8def\uff1a\u5bf9int\u8303\u56f4\u5185\u7684\u6574\u6570\u8fdb\u884c\u8d28\u56e0\u6570\u5206\u89e3\uff0c\u91c7\u7528\u6253\u8d28\u6570\u8868\u6cd5\u3002 \u6ce8\u610f\u7531\u4e8e\u524d10\u4e2a\u8d28\u6570\u4e58\u79ef\u5df2\u7ecf\u8d85\u8fc7int\u6700\u5927\u503c\u8303\u56f4\uff0c\u53ea\u9700\u8981\u5f00\u8f9fFactors\u5927\u5c0f\u4e3a10\u6765\u8bb0\u5f55\u6bcf\u4e2a\u8d28\u6570\u53ca\u5176\u91cd\u590d\u6b21\u6570\u3002 \u800c\u7531\u4e8e\u8d28\u56e0\u5b50\u5173\u4e8esqrt(n)\u7684\u5bf9\u79f0\u6027\u8d28\uff0c\u82e5\u5f53\u524d\u8d28\u56e0\u5b50&gt;sqrt(n)\u65f6\uff0c\u53ef\u5224\u65adn\u672c\u8eab\u5373\u4e3a\u8d28\u6570\u3002</p> <pre><code>#include&lt;cstdio&gt;\n\nconst int maxn = 100010;\n\nint prime[maxn];\nint pnum = 0;\n\nbool is_prime(int x) {\n    if(x &lt;= 1) return false;\n    for(int i = 2; i*i &lt;= x; i++) {\n        if(x % i == 0) return false;\n    }\n    return true;\n}\n\nvoid FindPrime() {\n    for(int i = 2; i &lt; maxn; i++) {\n        if(is_prime(i) == true) {\n            prime[pnum++] = i;\n        }\n    }\n}\n\ntypedef struct {\n    int x;\n    int cnt;\n} Factors;\n\nFactors fac[10];\n\nint main() {\n    FindPrime();\n    int n, num = 0;\n    scanf(\"%d\", &amp;n);\n    if(n == 1) {\n        printf(\"1=1\");\n        return 0;\n    }\n    printf(\"%d=\", n);\n    for(int i = 0; i &lt; pnum &amp;&amp; prime[i] * prime[i] &lt;= n; i++) {\n        if(n % prime[i] == 0) {\n            fac[num].x = prime[i];\n            fac[num].cnt = 0;\n            while(n % prime[i] == 0) {\n                fac[num].cnt++;\n                n /= prime[i];\n            }\n            num++;\n        }\n    }\n    if(n &gt; 1) {\n        fac[num].x = n;\n        fac[num++].cnt = 1;\n    }\n    for(int i = 0; i &lt; num; i++) {\n        printf(\"%d\", fac[i].x);\n        if(fac[i].cnt &gt; 1)\n            printf(\"^%d\", fac[i].cnt);\n        if(i &lt; num - 1) printf(\"*\");\n    }\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E8%B4%A8%E6%95%B0/PAT%20B1013_%E6%95%B0%E7%B4%A0%E6%95%B0/","title":"PAT B1013 \u6570\u7d20\u6570","text":"<p>\u601d\u8def\uff1a\u6c42\u7b2cM\u5230\u7b2cN\u4e2a\u7d20\u6570\uff0c\u91c7\u7528\u7d20\u6570\u7b5b\u6cd5\uff0c\u6838\u5fc3\u601d\u60f3\u662f\u4ece2\u5f00\u59cb\u505a\u589e\u91cf\u6392\u96644\uff0c6\uff0c8\uff0c10\u7b49\u3002 <pre><code>#include&lt;cstdio&gt;\n\nconst int maxn = 1000001;\nint prime[maxn];\nbool not_prime[maxn];\nint num;\n\nvoid FindPrime(int n) {\n    for(int i = 2; i &lt; maxn; i++) {\n        if(not_prime[i] == false) {\n            prime[num++] = i;\n            if(num &gt;= n) break;\n            for(int j = 2*i; j &lt; maxn; j += i) {\n                not_prime[j] = true;\n            }\n        }\n    }\n}\n\nint main() {\n    int M, N;\n    scanf(\"%d %d\", &amp;M, &amp;N);\n    FindPrime(N);\n    int cnt = 0;\n    for(int i = M; i &lt;= N; i++) {\n        printf(\"%d\", prime[i-1]);\n        cnt++;\n        if(cnt % 10 != 0 &amp;&amp; i &lt; N) printf(\" \");\n        else printf(\"\\n\");\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E9%80%92%E6%8E%A8/PAT%20A1001_Quick%20Sort/","title":"PAT A1001 Quick Sort","text":"<p>\u601d\u8def\uff1a\u4e0eA1093\u76f8\u4f3c\uff0c\u9488\u5bf9\u6bcf\u4e2a\u6570\u7edf\u8ba1\u5176\u5de6\u8fb9\u7684\u6700\u5927\u503c\u4ee5\u53ca\u53f3\u8fb9\u7684\u6700\u5c0f\u503c\u3002\u5982\u679c\u6ee1\u8db3\u5f53\u524d\u6570\u5927\u4e8e\u5de6\u8fb9\u6700\u5927\u503c\u4e14\u5c0f\u4e8e\u53f3\u8fb9\u6700\u5c0f\u503c\uff0c\u5219\u6ee1\u8db3\u6761\u4ef6\u3002\u6700\u5927\u503c\u7528\u6570\u7ec4\u7edf\u8ba1\uff0c\u6700\u5c0f\u503c\u53ea\u8bbe\u53d8\u91cfrightMin\uff0c\u5728\u7edf\u8ba1rightMin\u7684\u5faa\u73af\u4e2d\u7edf\u8ba1\u6ee1\u8db3\u8981\u6c42\u7684\u4e0b\u6807\u8fdb\u800c\u5f97\u51fa\u7b54\u6848\u3002</p> <p>\u76f8\u4f3c\u9898\u76ee\uff1aPAT A1093 CountPATs <pre><code>#include&lt;cstdio&gt;\n#define MAXN 100005\n\nint nums[MAXN];\nint leftMAX[MAXN];\nint ans[MAXN];\n\nint main() {\n    int n;\n    scanf(\"%d\", &amp;n);\n    for(int i = 0; i &lt; n; i++) {\n        scanf(\"%d\", &amp;nums[i]);\n    }\n    leftMAX[0] = nums[0];\n    for(int i = 1; i &lt; n; i++) {\n        leftMAX[i] = leftMAX[i-1];\n        if(nums[i] &gt; leftMAX[i]) {\n            leftMAX[i] = nums[i];\n        }\n    }\n    int count = 0;\n    int rightMin = nums[n-1];\n    for(int i = n-1; i &gt;= 0; i--) {\n        if(nums[i] &lt;= rightMin) {\n            rightMin = nums[i];\n            if(nums[i] &gt;= leftMAX[i]) {\n                ans[count++] = i;\n            }\n        }\n    }\n    printf(\"%d\\n\", count);\n    for(int i = count-1; i &gt;= 0; i--) {\n        printf(\"%d\", nums[ans[i]]);\n        if(i &gt; 0) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E9%80%92%E6%8E%A8/PAT%20A1093_CountPATs/","title":"PAT A1093 CountPATs","text":"<p>\u601d\u8def\uff1a\u9488\u5bf9\u6bcf\u4e2a\u7279\u5b9a\u7684A\uff0c\u7edf\u8ba1\u5176\u5de6\u4fa7P\u7684\u6570\u91cf\u548c\u53f3\u4fa7T\u7684\u6570\u91cf\uff0c\u5bf9\u7b54\u6848\u7684\u8d21\u732e\u4e3aP*T\u7684\u503c\u3002P\u7684\u6570\u91cf\u91c7\u7528\u6570\u7ec4\uff0cans\u5728\u7edf\u8ba1T\u7684\u8fc7\u7a0b\u4e2d\u8ba1\u7b97\u51fa\u3002</p> <p>\u76f8\u4f3c\u9898\u76ee\uff1aPAT A1001 Quick Sort <pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n#define MAXN 100005\n#define MOD 1000000007\n\nint leftNum[MAXN];\nchar str[MAXN];\n\nint main() {\n    fgets(str, MAXN, stdin);\n    int len = strlen(str);\n    if(str[0] == 'P') leftNum[0] = 1;\n    for(int i = 1; i &lt; len; i++) {\n        leftNum[i] = leftNum[i-1];\n        if(str[i] == 'P') leftNum[i]++;\n    }\n    int rightNum = 0;\n    int ans = 0;\n    for(int i = len-1; i &gt;= 0; i--) {\n        if(str[i] == 'T') {\n            rightNum++;\n        } else if(str[i] == 'A') {\n            ans = (ans + (leftNum[i] * rightNum) % MOD) % MOD;\n        }\n    }\n    printf(\"%d\", ans);\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/PAT%20A1032_Sharing/","title":"PAT A1032 Sharing","text":"<p>\u601d\u8def\uff1a\u5c06\u8f93\u5165\u7684\u94fe\u8868\u7528\u9759\u6001\u94fe\u8868\u5b58\u50a8\uff0c\u5bf9\u7b2c\u4e00\u6761\u94fe\u8868\u7684\u6240\u6709\u7ed3\u70b9\u91c7\u7528flag\u6807\u8bb0\uff0c\u5728\u904d\u5386\u7b2c\u4e8c\u6761\u94fe\u8868\u65f6\u68c0\u67e5\u8be5\u6807\u8bb0\uff0c\u51fa\u73b0\u6807\u8bb0\u5373\u4e3a\u7b2c\u4e00\u4e2a\u91cd\u5408\u7684\u7ed3\u70b9\uff0c\u5426\u5219\u4e24\u4e2a\u94fe\u8868\u4e0d\u5b58\u5728\u91cd\u5408\u7684\u7ed3\u70b9\u3002 <pre><code>#include&lt;cstdio&gt;\n#include&lt;cstring&gt;\n\nconst int maxn = 100005;\n\ntypedef struct {\n    bool flag;\n    char data;\n    int next;\n} Node;\n\nNode node[maxn];\n\nint main() {\n    int s1, s2, n;\n    scanf(\"%d %d %d\", &amp;s1, &amp;s2, &amp;n);\n    int addr, next;\n    char data;\n    for(int i = 0; i &lt; n; i++) {\n        scanf(\"%d %c %d\", &amp;addr, &amp;data, &amp;next);\n        node[addr].data = data;\n        node[addr].next = next;\n    }\n    while(s1 != -1) {\n        node[s1].flag = true;\n        s1 = node[s1].next;\n    }\n    while(s2 != -1) {\n        if(node[s2].flag == true) {\n            break;\n        }\n        s2 = node[s2].next;\n    }\n    if(s2 != -1) {\n        printf(\"%05d\", s2);\n    } else {\n        printf(\"-1\");\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/PAT%20A1052_Linked%20List%20Sorting/","title":"PAT A1052 Linked List Sorting","text":"<p>\u601d\u8def\uff1a\u7531\u4e8e\u9898\u76ee\u6240\u7ed9\u7ed3\u70b9\u4e2d\u952e\u503c\u552f\u4e00\uff0c\u53ef\u76f4\u63a5\u6839\u636e\u952e\u503c\u6392\u5e8f\uff0c\u6ce8\u610f\u8f93\u5165\u4e2d\u7684\u7ed3\u70b9\u53ef\u80fd\u5e76\u4e0d\u5c5e\u4e8e\u94fe\u8868\uff0c\u9700\u8981\u5728Node\u4e2d\u6dfb\u52a0flag\u6807\u5fd7\u67e5\u770b\u662f\u5426\u5904\u4e8e\u9898\u76ee\u7684\u94fe\u8868\u4e2d\uff0c\u5e76\u6839\u636e\u6b64\u7f16\u5199cmp\u51fd\u6570\u5c06\u5176\u6392\u5e8f\u5230\u672b\u5c3e\u3002</p> <pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconst int maxn = 100005;\n\ntypedef struct {\n    int addr;\n    int data;\n    int next;\n    bool flag;\n} Node;\n\nNode node[maxn];\n\nbool cmp(Node a, Node b) {\n    if(a.flag == false || b.flag == false) {\n        return a.flag &gt; b.flag;\n    }\n    return a.data &lt; b.data;\n}\n\nint main() {\n    int n, s1;\n    scanf(\"%d %d\", &amp;n, &amp;s1);\n    int addr, data, next;\n    for(int i = 0; i &lt; n; i++) {\n        scanf(\"%d %d %d\", &amp;addr, &amp;data, &amp;next);\n        node[addr].addr = addr;\n        node[addr].data = data;\n        node[addr].next = next;\n        node[addr].flag = false;\n    }\n    int p = s1, cnt = 0;\n    while(p != -1) {\n        node[p].flag = true;\n        p = node[p].next;\n        cnt++;\n    }\n    if(cnt == 0) printf(\"0 -1\\n\");\n    else {\n        sort(node, node + maxn, cmp);\n        printf(\"%d %05d\\n\", cnt, node[0].addr);\n        for(int i = 0; i &lt; cnt; i++) {\n            if(i &lt; cnt-1) {\n                printf(\"%05d %d %05d\\n\", node[i].addr, node[i].data, node[i+1].addr);\n            } else {\n                printf(\"%05d %d -1\\n\", node[i].addr, node[i].data);\n            }\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/PAT%20A1097_Deduplication%20on%20a%20Linked%20List/","title":"PAT A1097 Deduplication on a Linked List","text":"<p>\u601d\u8def\uff1a\u904d\u5386\u7ed9\u51fa\u7684\u9759\u6001\u94fe\u8868\uff0c\u901a\u8fc7\u8bbe\u7f6e\u6807\u8bb0\u6570\u7ec4\u8bb0\u5f55\u6bcf\u4e2a\u952e\u503c\u662f\u5426\u5df2\u7ecf\u51fa\u73b0\u8fc7\u3002\u6bcf\u4e2a\u7ed3\u70b9\u8d4b\u4e88\u4e00\u4e2aorder\u6392\u5e8f\u503c\uff0c\u521d\u59cb\u65f6\u6240\u6709\u7ed3\u70b9\u7684order\u521d\u59cb\u5316\u4e3a2*maxn\uff0c\u672a\u51fa\u73b0\u8fc7\u7684\u952e\u503c\u7ed3\u70b9\u8d4b\u503cvalid\u4ece0\u5f00\u59cb\uff0c\u6700\u7ec8\u503c\u4e3a\u6709\u6548\u7ed3\u70b9\u7684\u6570\u91cf\u3002\u51fa\u73b0\u8fc7\u8981\u88ab\u5220\u9664\u7684\u7ed3\u70b9\u952e\u503c\u6309\u7167removed + maxn\u8fdb\u884c\u8d4b\u503c\uff0cremoved\u4ece0\u5f00\u59cb\uff0c\u6700\u7ec8\u503c\u4e3a\u88ab\u5220\u9664\u7684\u7ed3\u70b9\u6570\u91cf\u3002\u8c03\u7528sort\u6309\u7167order\u8fdb\u884c\u6392\u5e8f\u3002 <pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\n\nconst int maxn = 100005;\nconst int table_size = 10005;\ntypedef struct {\n    int addr, key, next, order;\n} Node;\n\nNode node[maxn];\nbool keyExist[table_size];\n\nint abs(int x) {\n    if(x &gt; 0) return x;\n    return -x;\n}\n\nbool cmp(Node a, Node b) {\n    return a.order &lt; b.order;\n}\n\nint main() {\n    int s1, n;\n    scanf(\"%d %d\", &amp;s1, &amp;n);\n    int addr, key, next;\n    for(int i = 0; i &lt; n; i++) {\n        scanf(\"%d %d %d\", &amp;addr, &amp;key, &amp;next);\n        node[addr].addr = addr;\n        node[addr].key = key;\n        node[addr].next = next;\n    }\n    for(int i = 0; i &lt; maxn; i++)\n        node[i].order = 2 * maxn;\n    int valid = 0, removed = 0, p = s1, data;\n    while(p != -1) {\n        data = abs(node[p].key);\n        if(!keyExist[data]) {\n            keyExist[data] = true;\n            node[p].order = valid++;\n        } else {\n            node[p].order = maxn + removed++;\n        }\n        p = node[p].next;\n    }\n    sort(node, node + maxn, cmp);\n    int total = valid + removed;\n    for(int i = 0; i &lt; total; i++) {\n        if(i != valid - 1 &amp;&amp; i != total - 1) \n            printf(\"%05d %d %05d\\n\", node[i].addr, node[i].key, node[i + 1].addr);   \n        else \n            printf(\"%05d %d -1\\n\", node[i].addr, node[i].key);\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/LeetCode%2025.K%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","title":"LeetCode 25.K\u4e2a\u4e00\u7ec4\u53cd\u8f6c\u94fe\u8868","text":"<p>\u601d\u8def\uff1ap0\u8bbe\u4e3a\u4e0a\u4e00\u7ec4\u53cd\u8f6c\u94fe\u8868\u7684\u6700\u540e\u4e00\u4e2a\u7ed3\u70b9\uff0c\u8bbe\u7f6edummy\u8282\u70b9\u4f5c\u4e3a\u54e8\u5175\uff0c\u4e00\u6b65\u4e00\u6b65\u5c40\u90e8\u53cd\u8f6c\u5b8c\u7ec4\u5185\u94fe\u8868\u540e\uff0c\u518d\u5b8c\u5584\u7ec4\u4e4b\u95f4\u7684\u53cd\u8f6c\u5173\u7cfb\u3002 <pre><code>class Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        ListNode* dummy = new ListNode(0);\n        dummy-&gt;next = head;\n        ListNode* cur = head, *pre = NULL, *next, *p0 = dummy;\n        int n = 0;\n        while(cur) {\n            n++;\n            cur = cur-&gt;next;\n        }\n        cur = head;\n        while(n &gt;= k) {\n            n -= k;\n            for(int i = 0; i &lt; k; i++) {\n                next = cur-&gt;next;\n                cur-&gt;next = pre;\n                pre = cur;\n                cur = next;\n            }\n            next = p0-&gt;next;\n            p0-&gt;next-&gt;next = cur;\n            p0-&gt;next = pre;\n            p0 = next;\n        }\n        return dummy-&gt;next;\n    }\n};\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/PAT%20A1074_Reversing%20Linked%20List/","title":"PAT A1074 Reversing Linked List","text":"<p>\u601d\u8def\uff1a\u7531\u4e8ePAT\u8f93\u5165\u6570\u636e\u7684\u7279\u6b8a\u6027\uff0c\u672c\u9898\u8003\u8651\u7528\u9759\u6001\u94fe\u8868\u6765\u5b9e\u73b0\uff0c\u6ce8\u610f\u8f93\u5165\u6570\u636e\u4e2d\u53ef\u80fd\u6709\u65e0\u6548\u7684\u7ed3\u70b9\uff0c\u56e0\u6b64\u9700\u8981\u53bf\u904d\u5386\u4e00\u6b21\u5e76\u4e14\u786e\u5b9a\u6709\u6548\u7ed3\u70b9\u6570order\uff0c\u5e76\u4e14\u4e3a\u6bcf\u4e2a\u6709\u6548\u7ed3\u70b9\u9644\u4e0a\u987a\u5e8f\u6807\u8bb0\u3002\u6839\u636e\u987a\u5e8f\u6807\u8bb0\u8fdb\u884c\u6392\u5e8f\u540e\u76f4\u63a5\u5bf9\u9759\u6001\u94fe\u8868\u6570\u7ec4\u4e2d\u524dorder\u4e2a\u7ed3\u70b9\u8fdb\u884c\u8f93\u51fa\uff0c\u6bcfk\u4e2a\u7ed3\u70b9\u5012\u5e8f\u8f93\u51fa\uff0c\u6700\u540e\u4e00\u7ec4\u82e5\u4e0d\u6ee1\u8db3k\u4e2a\u7ed3\u70b9\u5219\u6309\u6b63\u5e38\u987a\u5e8f\u8f93\u51fa\u3002</p> <p>\u76f8\u4f3c\u9898\u76ee\uff1aLeetCode 25.K\u4e2a\u4e00\u7ec4\u53cd\u8f6c\u94fe\u8868 <pre><code>#include&lt;cstdio&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\nconst int maxn = 100005;\ntypedef struct {\n    int addr, data, next;\n    int order;\n} Node;\nNode node[maxn];\nbool cmp(Node a, Node b) {\n    return a.order &lt; b.order;\n}\nint main() {\n    int s1, n, k;\n    scanf(\"%d %d %d\", &amp;s1, &amp;n, &amp;k);\n    int addr, data, next;\n    for(int i = 0; i &lt; maxn; i++) \n        node[i].order = maxn;\n    for(int i = 0; i &lt; n; i++) {\n        scanf(\"%d %d %d\", &amp;addr, &amp;data, &amp;next);\n        node[addr].addr = addr;\n        node[addr].data = data;\n        node[addr].next = next;\n    }\n    int p = s1, order = 0;\n    while(p != -1) {\n        node[p].order = order++;\n        p = node[p].next;\n    }\n    sort(node, node + maxn, cmp);\n    for(int i = 0; i &lt; order / k; i++) {\n        for(int j = (i + 1) * k - 1; j &gt; i * k; j--) \n            printf(\"%05d %d %05d\\n\", node[j].addr, node[j].data, node[j-1].addr);\n        printf(\"%05d %d \", node[i * k].addr, node[i * k].data);\n        if(i &lt; order / k - 1)\n            printf(\"%05d\\n\", node[(i + 2) * k - 1].addr);\n        else {\n            if(order % k == 0) \n                printf(\"-1\\n\");\n            else {\n                printf(\"%05d\\n\", node[(i + 1) * k].addr);\n                for(int m = order / k * k; m &lt; order; m++) {\n                    printf(\"%05d %d \", node[m].addr, node[m].data);\n                    if(m &lt; order - 1)\n                        printf(\"%05d\\n\", node[m+1].addr);\n                    else printf(\"-1\\n\");\n                }\n            }\n        }\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"%E5%88%B7%E9%A2%98/%E9%98%9F%E5%88%97/PAT%20A1056_Mice%20and%20Rice/","title":"PAT A1056 Mice and Rice","text":"<p>\u601d\u8def\uff1a\u6bcf\u8f6e\u53ef\u5206\u6210a\u7ec4\uff0c\u5176\u4e2d\u6700\u540e\u4e00\u7ec4\u53ef\u80fd\u4e0d\u4f1a\u4eba\u6ee1\u3002\u5c06\u6240\u6709\u4eba\u7684\u521d\u59cb\u5e8f\u5217\u8f93\u5165\u961f\u5217\u4e2d\uff0c\u6bcf\u6b21\u6bd4\u8d5b\u4e00\u5171\u9009\u51faa\u4e2a\u4e0b\u4e00\u8f6e\u9009\u624b\uff0c \u5373\u88ab\u6dd8\u6c70\u7684\u9009\u624b\u5904\u4e8ea + 1\u540d\u3002\u4e0b\u4e00\u8f6e\u5c31\u6709a\u4eba\u53c2\u8d5b\uff0c\u6839\u636e\u6bcf\u7ec4\u7684\u6700\u5927\u4eba\u6570\u53ef\u5c06\u4e0b\u4e00\u8f6e\u7684a\u4eba\u7ee7\u7eed\u5206\u7ec4\u5982\u6b64\u5faa\u73af\u76f4\u5230\u961f\u5217\u4e2d\u53ea\u5269\u4e0b1\u4eba\u5373\u4e3a\u6392\u540d\u7b2c\u4e00\u7684\u9009\u624b\u3002\u6ce8\u610f\uff0c\u6bcf\u4e2a\u5c0f\u7ec4\u7684\u6bd4\u8d5b\u4e2d\u90fd\u63d0\u524d\u7ed9\u53c2\u8d5b\u9009\u624b\u8bbe\u4e0b\u6392\u540d\u4e3aa + 1\uff0c\u4e0d\u5f71\u54cd\u540e\u7eed\u6392\u540d\u66f4\u65b0\u3002 <pre><code>#include&lt;cstdio&gt;\n#include&lt;queue&gt;\nusing namespace std;\nconst int maxn = 1005;\ntypedef struct {\n    int weight;\n    int rank;\n} Mouse;\nMouse mouse[maxn];\n\nint main() {\n    int N_P, N_G;\n    scanf(\"%d %d\", &amp;N_P, &amp;N_G);\n    for(int i = 0; i &lt; N_P; i++) {\n        scanf(\"%d\", &amp;mouse[i].weight);\n    }\n    int init_order;\n    queue&lt;int&gt; q;\n    for(int i = 0; i &lt; N_P; i++) {\n        scanf(\"%d\", &amp;init_order);\n        q.push(init_order);\n    }\n    int n = N_P, group;\n    while(q.size() != 1) {\n        group = n / N_G;\n        if(n % N_G) group++;\n        for(int i = 0; i &lt; group; i++) {\n            int idx = q.front();\n            q.pop();\n            mouse[idx].rank = group + 1;\n            for(int j = 1; j &lt; N_G; j++) {\n                if(i * N_G + j &gt;= n) break;\n                int front = q.front();\n                q.pop();\n                mouse[front].rank = group + 1;\n                if(mouse[front].weight &gt; mouse[idx].weight) {\n                    idx = front;\n                }\n            }\n            q.push(idx);\n        }\n        n = group;\n    }\n    mouse[q.front()].rank = 1;\n    for(int i = 0; i &lt; N_P; i++) {\n        printf(\"%d\", mouse[i].rank);\n        if(i &lt; N_P - 1) printf(\" \");\n    }\n    return 0;\n}\n</code></pre></p>"},{"location":"%E6%9D%82%E9%A1%B9/","title":"\u5199\u5728\u524d\u9762","text":"<p>\u6458\u8981</p> <p>\u6742\u9879\u9875\u9762\u4e2d\u4e3b\u8981\u8bb0\u5f55\u4e00\u4e9b\u76f8\u5bf9\u72ec\u7acb\u7684\u77e5\u8bc6\u6280\u672f\u4ecb\u7ecd\u3002</p>"},{"location":"%E6%9D%82%E9%A1%B9/Win11%E5%AE%B6%E5%BA%AD%E7%89%88%E9%85%8D%E7%BD%AEWSL2/1/","title":"Win11 \u5bb6\u5ead\u7248\u914d\u7f6e WSL2","text":""},{"location":"%E6%9D%82%E9%A1%B9/Win11%E5%AE%B6%E5%BA%AD%E7%89%88%E9%85%8D%E7%BD%AEWSL2/1/#0-\u5b89\u88c5\u73af\u5883","title":"0. \u5b89\u88c5\u73af\u5883","text":"<p>\u7b14\u8005\u4f7f\u7528\u7684\u64cd\u4f5c\u7cfb\u7edf\u4e3a Windows 11 \u5bb6\u5ead\u7248\uff0cCPU \u4e3a AMD Ryzen \u7cfb\u5217\u3002</p> <p>\u672c\u6559\u7a0b\u5c06\u5b89\u88c5 WSL2 \u81f3\u975eC\u76d8\uff08D\u76d8\uff09\u3002</p> <p>\u7531\u4e8e Windows 11 \u5bb6\u5ead\u7248\u4e0d\u652f\u6301 Hyper-V \u529f\u80fd\uff0c\u9700\u8981\u624b\u52a8\u8bbe\u7f6e\u5f00\u542f\u3002</p> <p>\u65b0\u5efa txt \u6587\u4ef6\u547d\u540d\u4e3a hyper-v (hyper-v.txt)\uff0c\u5e76\u590d\u5236\u4e0b\u8ff0\u4ee3\u7801\u5185\u5bb9\u3002</p> <pre><code>pushd \"%~dp0\"\n\ndir /b %SystemRoot%\\servicing\\Packages\\*Hyper-V*.mum &gt;hyper-v.txt\n\nfor /f %%i in ('findstr /i . hyper-v.txt 2^&gt;nul') do dism /online /norestart /add-package:\"%SystemRoot%\\servicing\\Packages\\%%i\"\n\ndel hyper-v.txt\n\nDism /online /enable-feature /featurename:Microsoft-Hyper-V-All /LimitAccess /ALL\n\npause\n</code></pre> <p>\u4fee\u6539\u6587\u4ef6\u540e\u7f00\u4e3a .cmd\uff0c\u5373\u4fdd\u5b58\u4e3a cmd \u683c\u5f0f\u7684\u6587\u4ef6\uff08\u9700\u8981\u5148\u53d6\u6d88\u9690\u85cf\u6587\u4ef6\u540e\u7f00\u540d\u529f\u80fd\uff09\u3002</p> <p>\u53f3\u952e\u70b9\u51fb\u4ee5\u7ba1\u7406\u5458\u8eab\u4efd\u8fd0\u884c\uff0c\u53ef\u80fd\u51fa\u73b0\u5faa\u73af\u8fd0\u884c\u73b0\u8c61\uff0c\u6ce8\u610f\u5173\u95ed\u3002</p> <p>\u8e29\u5751</p> <p>\u7b14\u8005\u5b89\u88c5\u8fc7\u7a0b\u4e2d\u66fe\u5c06\u4e0a\u8ff0\u6587\u4ef6\u540e\u7f00\u6539\u4e3a .bat\uff0c\u4f1a\u62a5\u9519 \u201cMicrosoft-Hyper-V \u672a\u77e5\u3002 \u672a\u8bc6\u522b\u51fa Windows \u529f\u80fd\u540d\u79f0\u3002\u201d\u3002</p> <p>\u5b8c\u6210\u4e0a\u8ff0\u51c6\u5907\u540e\uff0c\u5728\u542f\u7528\u6216\u5173\u95ed Windows \u529f\u80fd\u9762\u677f\u5904\u52fe\u9009\u4ee5\u4e0b\u51e0\u9879\uff1a</p> <ul> <li>Hyper-V</li> <li>Windows \u865a\u62df\u673a\u76d1\u63a7\u5e73\u53f0</li> <li>\u9002\u7528\u4e8e Linux \u7684 Windows \u5b50\u7cfb\u7edf</li> <li>\u865a\u62df\u673a\u5e73\u53f0</li> </ul> <p></p>"},{"location":"%E6%9D%82%E9%A1%B9/Win11%E5%AE%B6%E5%BA%AD%E7%89%88%E9%85%8D%E7%BD%AEWSL2/1/#1-\u5b89\u88c5\u5305\u4e0b\u8f7d","title":"1. \u5b89\u88c5\u5305\u4e0b\u8f7d","text":"<p>\u5728\u7cfb\u7edf\u81ea\u5e26\u5e94\u7528\u4e2d\u6253\u5f00 Microsoft Store\uff0c\u641c\u7d22 Ubuntu \u5e76\u6311\u9009\u81ea\u5df1\u9700\u8981\u7684\u7248\u672c\u8fdb\u884c\u4e0b\u8f7d\uff0c\u6b64\u5904\u4e3a 22.04.3 LTS \u7248\u672c\u3002</p> <p></p>"},{"location":"%E6%9D%82%E9%A1%B9/Win11%E5%AE%B6%E5%BA%AD%E7%89%88%E9%85%8D%E7%BD%AEWSL2/1/#2-\u63d0\u53d6\u5b89\u88c5\u5305","title":"2. \u63d0\u53d6\u5b89\u88c5\u5305","text":"<p>\u4e0b\u8f7d\u5b8c\u6210\u540e\uff0c\u5148\u4e0d\u8981\u8fd0\u884c\u3002\u4f7f\u7528\u7ba1\u7406\u5458\u8eab\u4efd\u8fd0\u884c\u547d\u4ee4\u884c\uff0c\u8f93\u5165 <code>cd C:\\Program Files\\WindowsApps</code> \u5373\u8fdb\u5165\u5230\u9ed8\u8ba4\u7684\u5546\u5e97\u5e94\u7528\u4fdd\u5b58\u8def\u5f84\u3002</p> <p>\u952e\u5165 <code>dir/od</code> \u6765\u67e5\u770b\u591a\u51fa\u6765\u7684\u5b50\u76ee\u5f55\u3002\u9700\u8981\u9009\u62e9\u5e26\u6709 Ubuntu \u4ee5\u53ca x64 \u5b57\u6837\u7684\u76ee\u5f55\uff0c\u5148\u8bb0\u4f4f\u5927\u81f4\u7684\u76ee\u5f55\u540d\u3002</p> <p></p> <p>\u63a5\u4e0b\u6765\u4f7f\u7528\u6587\u4ef6\u8d44\u6e90\u7ba1\u7406\u5668\u627e\u5230\u5bf9\u5e94\u76ee\u5f55\uff0c\u8bbe\u7f6e\u6253\u5f00\u6743\u9650\u3002</p> <p>\u4f9d\u6b21\u70b9\u5f00 \u5c5e\u6027-&gt;\u5b89\u5168-&gt;\u9ad8\u7ea7-&gt;\u66f4\u6539\u6240\u6709\u8005\uff0c\u8f93\u5165 everyone\u3002\uff08\u53ef\u80fd\u5b58\u5728\u5b89\u5168\u98ce\u9669\uff0c\u8bf7\u614e\u91cd\u8003\u8651\uff09</p> <p></p> <p>\u52fe\u9009\u66ff\u6362\u5b50\u5bb9\u5668\u548c\u5bf9\u8c61\u7684\u6240\u6709\u8005\uff0c\u5e94\u7528\u5e76\u786e\u5b9a\u3002</p> <p></p> <p>\u6253\u5f00\u540e\u9009\u62e9\u4e0a\u8ff0\u786e\u5b9a\u7684\u5b50\u76ee\u5f55\u7684\u6240\u6709\u5185\u5bb9\uff0c\u590d\u5236\u5230D\u76d8\u7684\u65b0\u5efa\u6587\u4ef6\u5939\u3002\u4f8b\u5982\uff1a<code>D:\\WSL2-Ubuntu-22.04</code></p> <p></p>"},{"location":"%E6%9D%82%E9%A1%B9/Win11%E5%AE%B6%E5%BA%AD%E7%89%88%E9%85%8D%E7%BD%AEWSL2/1/#3-\u5b89\u88c5\u5b9e\u4f8b","title":"3. \u5b89\u88c5\u5b9e\u4f8b","text":"<p>\u5728\u547d\u4ee4\u884c\u4e2d\u8f93\u5165 <code>wsl --set-default-version 2</code>\uff0c\u8868\u793a\u9ed8\u8ba4\u4f7f\u7528 WSL2 \u7684\u65b9\u5f0f\u8fdb\u884c\u5b89\u88c5\u3002</p> <p>\u4e0b\u8f7d Windows Subsystem for Linux Update Setup \u7a0b\u5e8f\u8fdb\u884c\u5b89\u88c5\uff0c\u94fe\u63a5\u81ea\u884c\u641c\u7d22\u6216\u70b9\u51fb\u4e0b\u65b9\u3002</p> <p>https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi</p> <p></p> <p>\u4e00\u8def\u70b9\u51fb Next \u8fdb\u884c\u5b89\u88c5\u5373\u53ef\u3002 </p> <p>\u5b8c\u6210\u540e\u63a5\u4e0b\u6765\u76f4\u63a5\u70b9\u51fb <code>D:\\WSL2-Ubuntu-22.04\\ubuntu2204.exe</code> \u8fdb\u884c\u5b89\u88c5\u3002</p> <p>\u5b89\u88c5\u5b8c\u6210\u540e\u53ef\u5728\u547d\u4ee4\u884c\u8f93\u5165 <code>wsl --status</code> \u6765\u68c0\u67e5\u662f\u5426\u4e3a WSL2\u3002</p> <p></p>"},{"location":"%E6%9D%82%E9%A1%B9/Win11%E5%AE%B6%E5%BA%AD%E7%89%88%E9%85%8D%E7%BD%AEWSL2/1/#4-\u5b89\u88c5\u5305\u6e05\u7406","title":"4. \u5b89\u88c5\u5305\u6e05\u7406","text":"<p>\u5148\u6253\u5f00\u5f00\u59cb\u83dc\u5355\uff0c\u53ef\u89c1\u521a\u624d\u5b89\u88c5\u7684\u53d1\u884c\u7248\uff0c\u9009\u62e9\u5378\u8f7d\uff08\u89c1\u4e0b\u56fe\uff09\u3002</p> <p>\u5378\u8f7d\u7684\u4f5c\u7528\u4e3a\u6e05\u9664\u4e0a\u8ff0C\u76d8\u4e2dWindowsApps\u76ee\u5f55\u4e2d\u7684\u5b89\u88c5\u5305\uff0c\u4e0d\u4f1a\u5bf9D\u76d8\u7684WSL2\u9020\u6210\u5f71\u54cd\u3002</p> <p></p> <p>\u6b64\u5916\uff0c <code>D:\\WSL2-Ubuntu-22.04\\install.tar.gz</code>  \u4e5f\u53ef\u624b\u52a8\u4ece\u6587\u4ef6\u5939\u4e2d\u5220\u9664\uff0c\u5176\u5185\u5bb9\u5df2\u7ecf\u89e3\u538b\u5b89\u88c5\u3002</p> <p>\u81f3\u6b64\uff0cWSL2 \u5b89\u88c5\u5b8c\u6bd5\u3002</p>"},{"location":"%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/","title":"\u6df1\u5ea6\u5b66\u4e60","text":"<p>\u6458\u8981</p> <p>\u8be5\u9875\u9762\u4e2d\u8bb0\u5f55\u6df1\u5ea6\u5b66\u4e60\u76f8\u5173\u7684\u5b66\u4e60\u7b14\u8bb0\u7b49\u3002</p>"},{"location":"%E8%AF%AD%E8%A8%80/","title":"\u8bed\u8a00","text":"<p>\u6458\u8981</p> <p>\u8bed\u8a00\u9875\u9762\u4e2d\u8bb0\u5f55\u7f16\u7a0b\u8bed\u8a00\u7c7b\u7684\u90e8\u5206\u77e5\u8bc6\uff0c\u8f6c\u8f7d\u6ce8\u660e\u539f\u6587\u3002</p> <p>\u76ee\u524d\u4e3b\u8981\u4f7f\u7528\u7684\u8bed\u8a00\u6709\uff1aC++\u3002</p>"},{"location":"%E8%AF%AD%E8%A8%80/C%2B%2B/IO%E7%B1%BB/string%E6%B5%81/1/","title":"string \u6d41\u521d\u6b65\u8ba4\u8bc6\u4e0e\u8fd0\u7528","text":""},{"location":"%E8%AF%AD%E8%A8%80/C%2B%2B/IO%E7%B1%BB/string%E6%B5%81/1/#1-\u5f15\u8a00","title":"1 \u5f15\u8a00","text":"<p>\u5728 C++ \u7684\u4f7f\u7528\u4e2d\u6211\u4eec\u7ecf\u5e38\u7528\u5230 IO \u64cd\u4f5c\uff0c\u8ba9\u6211\u4eec\u56de\u987e\u4e00\u4e0b IO \u5e93\u7c7b\u578b\u548c\u5934\u6587\u4ef6\u3002</p> <ul> <li> <p>iostream \u5b9a\u4e49\u4e86\u7528\u4e8e\u8bfb\u5199\u6d41\u7684\u57fa\u672c\u7c7b\u578b\u3002</p> </li> <li> <p>fstream \u5b9a\u4e49\u4e86\u8bfb\u5199\u547d\u540d\u6587\u4ef6\u7684\u7c7b\u578b\u3002</p> </li> <li> <p>sstream \u5b9a\u4e49\u4e86\u8bfb\u5199\u5185\u5b58 string \u5bf9\u8c61\u7684\u7c7b\u578b\u3002</p> </li> </ul> <p> \u5934\u6587\u4ef6 \u7c7b\u578b iostream istream\uff0cwistream \u4ece\u6d41\u8bfb\u53d6\u6570\u636e ostream\uff0cwostream \u5411\u6d41\u5199\u5165\u6570\u636e iostream\uff0cwiostream \u8bfb\u5199\u6d41 fstream ifstream\uff0cwifstream \u4ece\u6587\u4ef6\u8bfb\u53d6\u6570\u636e ofstream\uff0cwofstream \u5411\u6587\u4ef6\u5199\u5165\u6570\u636e fstream\uff0cwfstream \u8bfb\u5199\u6587\u4ef6 sstream istringstream\uff0cwistringistream \u4ece string \u8bfb\u53d6\u6570\u636e ostringstream\uff0cwostringstream \u5411string\u5199\u5165\u6570\u636e  stringstream\uff0cwstringstream \u8bfb\u5199string <p></p> <p>\u672c\u6587\u4e3b\u8981\u5bf9 istringstream\u3001ostringstream \u548c stringstream \u8fdb\u884c\u521d\u6b65\u4ecb\u7ecd\u3002</p>"},{"location":"%E8%AF%AD%E8%A8%80/C%2B%2B/IO%E7%B1%BB/string%E6%B5%81/1/#2-istringstream-\u7c7b","title":"2 istringstream \u7c7b","text":"<p>istringstream \u7c7b\u4ece string \u4e2d\u63d0\u53d6\u6570\u636e\uff0c\u652f\u6301 &gt;&gt; \u64cd\u4f5c\uff0c\u9ed8\u8ba4\u5206\u5272\u7b26\u4e3a\u7a7a\u683c\u3002</p> <p>\u6784\u9020\u51fd\u6570\u539f\u578b\uff1a<code>istringstream::istringstream(string str)</code></p> <p>\u5e38\u7528\u6210\u5458\u51fd\u6570\uff1a<code>str()\uff1a\u4f7f istringstream \u5bf9\u8c61\u8fd4\u56de\u4e00\u4e2a string \u5b57\u7b26\u4e32</code></p> <p>\u793a\u4f8b\u7a0b\u5e8f\uff1a <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\nusing namespace std;\nint main() {\n    string sentence = \"Study Hard and Day Day Up\";\n    istringstream iss(sentence);\n    string temp;\n    // \u53ef\u7528 while(iss &gt;&gt; t) \u4ee3\u66ff\uff0c\u9ed8\u8ba4\u7a7a\u683c\u5206\u5272\n    while(getline(iss, temp, ' ')) {//\u6b64\u5904\u624b\u52a8\u6307\u5b9a\u7528\u7a7a\u683c\u5206\u9694\n        cout &lt;&lt; iss.str() &lt;&lt; \"#\";\n        cout &lt;&lt; temp &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre></p> <p>\u8f93\u51fa\u7ed3\u679c\uff1a <pre><code>Study Hard and Day Day Up#Study\nStudy Hard and Day Day Up#Hard \nStudy Hard and Day Day Up#and  \nStudy Hard and Day Day Up#Day  \nStudy Hard and Day Day Up#Day  \nStudy Hard and Day Day Up#Up \n</code></pre></p>"},{"location":"%E8%AF%AD%E8%A8%80/C%2B%2B/IO%E7%B1%BB/string%E6%B5%81/1/#3-ostringstream-\u7c7b","title":"3 ostringstream \u7c7b","text":"<p>ostringstream \u7c7b\u5c06\u5176\u4ed6\u7c7b\u578b\u6570\u636e\u5f80 string \u4e2d\u5199\u5165\uff0c\u652f\u6301 &lt;&lt; \u64cd\u4f5c\uff0c\u9ed8\u8ba4\u5206\u5272\u7b26\u4e3a\u7a7a\u683c\u3002</p> <p>\u6784\u9020\u51fd\u6570\u539f\u578b\uff1a<code>ostringstream::ostringstream(string str)</code></p> <p>\u5e38\u7528\u6210\u5458\u51fd\u6570\uff1a<code>str()\uff1a\u4f7f ostringstream \u5bf9\u8c61\u8fd4\u56de\u4e00\u4e2a string \u5b57\u7b26\u4e32\uff0c\u6216\u8005\u4f7f\u7528\u5176\u8fdb\u884c\u521d\u59cb\u5316</code></p> <p>\u793a\u4f8b\u7a0b\u5e8f\uff1a <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\nusing namespace std;\nint main() {\n    float num = 114.514;\n    ostringstream oss;\n    oss &lt;&lt; num;\n    cout &lt;&lt; oss.str() &lt;&lt; endl;\n    oss.str(\"1919810\");\n    cout &lt;&lt; oss.str() &lt;&lt; endl;\n    return 0;\n}\n</code></pre></p> <p>\u8f93\u51fa\u7ed3\u679c\uff1a <pre><code>114.514\n1919810\n</code></pre></p>"},{"location":"%E8%AF%AD%E8%A8%80/C%2B%2B/IO%E7%B1%BB/string%E6%B5%81/1/#4-stringstream-\u7c7b","title":"4 stringstream \u7c7b","text":""},{"location":"%E8%AF%AD%E8%A8%80/C%2B%2B/IO%E7%B1%BB/string%E6%B5%81/1/#41-\u5e38\u7528\u4ecb\u7ecd","title":"4.1 \u5e38\u7528\u4ecb\u7ecd","text":"<p>stringstream \u7c7b\u662f istringstream \u548c ostringstream \u7684\u7efc\u5408\uff0c\u652f\u6301 &lt;&lt;\uff0c&gt;&gt; \u64cd\u4f5c\uff0c\u901a\u5e38\u7528\u6765\u6570\u636e\u8f6c\u6362\u3002</p> <p>\u6784\u9020\u51fd\u6570\u539f\u578b\uff1a<code>stringstream::stringstream(string str)</code></p> <p>\u5e38\u7528\u6210\u5458\u51fd\u6570\uff1a <pre><code>str()\uff1a\u4f7f stringstream \u5bf9\u8c61\u8fd4\u56de\u4e00\u4e2a string \u5b57\u7b26\u4e32\uff0c\u6216\u8005\u4f7f\u7528\u5176\u8fdb\u884c\u521d\u59cb\u5316\u3002\n</code></pre> \u793a\u4f8b\u7a0b\u5e8f\uff1a <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\nusing namespace std;\nint main() {\n    float num = 114.514;\n    stringstream ss;\n    string s;\n    ss &lt;&lt; num;\n    ss &gt;&gt; s;\n    cout &lt;&lt; s &lt;&lt; endl;\n    return 0;\n}\n</code></pre></p> <p>\u8f93\u51fa\u7ed3\u679c\uff1a <pre><code>114.514\n</code></pre></p>"},{"location":"%E8%AF%AD%E8%A8%80/C%2B%2B/IO%E7%B1%BB/string%E6%B5%81/1/#42-clear-\u7684\u7528\u6cd5\u4ecb\u7ecd","title":"4.2 clear() \u7684\u7528\u6cd5\u4ecb\u7ecd","text":"<p>\u5148\u6765\u770b\u4e00\u6bb5\u4ee3\u7801\uff1a <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\nusing namespace std;\nint main() {\n    float num = 114.514;\n    stringstream ss(\"1919810\");\n    string s;\n\n    ss &gt;&gt; s;\n    cout &lt;&lt; ss.str() &lt;&lt; \" \";\n\n    //ss.clear();\n\n    ss &lt;&lt; num;\n    cout &lt;&lt; ss.str() &lt;&lt; endl;\n    return 0;\n}\n</code></pre> \u7f16\u5199\u5982\u4e0a\u4ee3\u7801\u65f6\uff0c\u6211\u4eec\u9884\u671f\u7684\u8f93\u51fa\u7ed3\u679c\u4e3a\uff1a<code>1919810 114.514</code></p> <p>\u5b9e\u9645\u8f93\u51fa\u7ed3\u679c\u4e3a\uff1a<code>1919810 1919810</code></p> <p>\u6211\u4eec\u53d1\u73b0\uff0c\u5728\u540e\u7eed\u6b65\u9aa4\u7684<code>ss &lt;&lt; num</code>\u5e76\u672a\u6b63\u786e\u6267\u884c\u3002 </p> <p>\u539f\u56e0\uff1a\u5728\u7b2c\u4e00\u6b21\u8c03\u7528\u5b8c<code>&gt;&gt;</code>\u548c<code>&lt;&lt;</code>\u540e\uff0c\u6765\u5230\u4e86 end-of-file \u7684\u4f4d\u7f6e\uff0c\u6b64\u65f6 stringstream \u4f1a\u4e3a\u5176\u8bbe\u7f6e\u4e00\u4e2a eofbit \u7684\u6807\u8bb0\u4f4d\uff0c\u6807\u8bb0\u5176\u4e3a\u5df2\u7ecf\u5230\u8fbe eof\u3002 \u5f53 stringstream \u8bbe\u7f6e\u4e86 eofbit\uff0c\u4efb\u4f55\u8bfb\u53d6 eof \u7684\u64cd\u4f5c\u90fd\u4f1a\u5931\u8d25\u3002\u540c\u65f6\uff0c\u4f1a\u8bbe\u7f6e failbit \u7684\u6807\u8bb0\u4f4d\uff0c\u6807\u8bb0\u4e3a\u5931\u8d25\u72b6\u6001\u3002\u6240\u4ee5\u540e\u9762\u7684\u64cd\u4f5c\u90fd\u5931\u8d25\u4e86\u3002</p> <p>\u89e3\u51b3\u65b9\u6cd5\uff1aclear \u51fd\u6570\u7684\u4f5c\u7528\u5c31\u662f\u6e05\u9664\u6389\u6240\u6709\u7684 error state \u4ee5\u53ca\u6d41\u72b6\u6001\uff0c\u6240\u4ee5\u5728\u4ee3\u7801\u524d\u9762\u52a0\u4e00\u4e2a<code>ss.clear()</code>\u5373\u53ef\u8fbe\u5230\u9884\u671f\u7ed3\u679c\u3002</p> <p>\u6ce8\u610f</p> <p>clear \u51fd\u6570\u7684\u4f5c\u7528\u5e76\u975e\u662f\u6e05\u7a7a\u7f13\u51b2\u533a\uff0c\u800c\u662f\u91cd\u7f6e\u6d41\u72b6\u6001\u3002stringstream.str(\"\") \u53ef\u6e05\u7a7a\u7f13\u51b2\u533a\uff0c\u4e24\u4e2a\u51fd\u6570\u7ecf\u5e38\u7ec4\u5408\u4f7f\u7528\u3002</p> <p>\u901a\u8fc7\u4ee5\u4e0b\u4e24\u4e2a\u793a\u4f8b\u7a0b\u5e8f\u7684\u5bf9\u6bd4\uff0c\u53ef\u4ee5\u76f4\u89c2\u5730\u4f53\u73b0\u51fa clear \u51fd\u6570 \u548c str(\"\") \u7684\u4f5c\u7528\u3002</p> <p>\u53ea\u8c03\u7528 clear \u51fd\u6570\u800c\u4e0d\u8c03\u7528 str(\"\")\uff1a <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\nusing namespace std;\nint main() {\n    stringstream ss;\n    string s1 = \"114\";\n    string s2 = \"514\";\n\n    ss &lt;&lt; s1;\n    cout &lt;&lt; ss.str() &lt;&lt; \" \";\n\n    ss.clear();\n    //ss.str(\"\");\n\n    ss &lt;&lt; s2;\n    cout &lt;&lt; ss.str() &lt;&lt; \" \";\n    return 0;\n}\n</code></pre> \u8f93\u51fa\u7ed3\u679c\uff1a<code>114 114514</code> </p> <p>\u540c\u65f6\u8c03\u7528 clear() \u548c str(\"\")\uff1a <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;sstream&gt;\nusing namespace std;\nint main() {\n    stringstream ss;\n    string s1 = \"114\";\n    string s2 = \"514\";\n\n    ss &lt;&lt; s1;\n    cout &lt;&lt; ss.str() &lt;&lt; \" \";\n\n    ss.clear();\n    ss.str(\"\");\n\n    ss &lt;&lt; s2;\n    cout &lt;&lt; ss.str() &lt;&lt; \" \";\n    return 0;\n}\n</code></pre> \u8f93\u51fa\u7ed3\u679c\uff1a<code>114 514</code></p> <p>\u4ee5\u4e0a\u662f\u5bf9 string \u6d41\u7684\u521d\u6b65\u4ecb\u7ecd\u3002</p>"},{"location":"%E8%AF%AD%E8%A8%80/C%2B%2B/IO%E7%B1%BB/%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6/1/","title":"\u683c\u5f0f\u63a7\u5236","text":""},{"location":"%E8%AF%AD%E8%A8%80/C%2B%2B/IO%E7%B1%BB/%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6/1/#1-\u5f15\u8a00","title":"1 \u5f15\u8a00","text":"<p>\u672c\u6587\u4e3b\u8981\u8bb2\u8ff0\u8f93\u51fa\u65f6\u4f5c\u683c\u5f0f\u63a7\u5236\u7684\u76f8\u5173\u5185\u5bb9\u3002</p>"},{"location":"%E8%AF%AD%E8%A8%80/C%2B%2B/IO%E7%B1%BB/%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6/1/#2-stdsetwint-n","title":"2 <code>std::setw(int n)</code>","text":"<p><code>std::setw(int n)</code>\u662f C++ \u5728\u8f93\u51fa\u64cd\u4f5c\u4e2d\u4f7f\u7528\u7684\u5b57\u6bb5\u5bbd\u5ea6\u8bbe\u7f6e\uff0c\u8bbe\u7f6e\u8f93\u51fa\u7684\u57df\u5bbd\uff0cn\u8868\u793a\u5b57\u6bb5\u5bbd\u5ea6\u3002</p> <p>\u53ea\u5bf9\u7d27\u63a5\u7740\u7684\u8f93\u51fa\u6709\u6548\uff0c\u7d27\u63a5\u7740\u7684\u8f93\u51fa\u7ed3\u675f\u540e\u53c8\u53d8\u56de\u9ed8\u8ba4\u7684\u57df\u5bbd\u3002\u5f53\u540e\u9762\u7d27\u8ddf\u7740\u7684\u8f93\u51fa\u5b57\u6bb5\u957f\u5ea6\u5c0f\u4e8en\u7684\u65f6\u5019\uff0c\u5728\u8be5\u5b57\u6bb5\u524d\u9762\u7528\u7a7a\u683c\u8865\u9f50\uff1b\u5f53\u8f93\u51fa\u5b57\u6bb5\u957f\u5ea6\u5927\u4e8en\u65f6\uff0c\u5168\u90e8\u6574\u4f53\u8f93\u51fa\u3002</p> <p>\u793a\u4f8b\u7a0b\u5e8f\uff1a <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\nusing namespace std;\nint main() {\n    string s = \"Study\";\n    cout &lt;&lt; s &lt;&lt; endl;\n    cout &lt;&lt; setw(10) &lt;&lt; s &lt;&lt; endl;\n    return 0;\n}\n</code></pre></p> <p>\u8f93\u51fa\u7ed3\u679c\uff1a <pre><code>Study     \n     Study\n</code></pre></p>"},{"location":"%E8%AF%AD%E8%A8%80/C%2B%2B/IO%E7%B1%BB/%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6/1/#3-stdfixed--stdsetprecisionint-n","title":"3 <code>std::fixed + std::setprecision(int n)</code>","text":"<p>\u5982\u679c\u4e00\u4e2a\u6570\u5b57\u592a\u5927\uff0c\u65e0\u6cd5\u4f7f\u7528<code>std::setprecision(int n)</code>\u6307\u5b9a\u7684\u6709\u6548\u6570\u4f4d\u6570\u6765\u6253\u5370\uff0c\u5219\u8bb8\u591a\u7cfb\u7edf\u4f1a\u4ee5\u79d1\u5b66\u8868\u793a\u6cd5\u7684\u65b9\u5f0f\u6253\u5370\u3002</p> <p><code>std::setprecision(int n)</code> \u5c06\u6307\u5b9a\u6d6e\u70b9\u6570\u5b57\u7684\u5c0f\u6570\u70b9\u540e\u8981\u663e\u793a\u7684\u4f4d\u6570\uff0c\u800c\u4e0d\u662f\u8981\u663e\u793a\u7684\u603b\u6709\u6548\u6570\u4f4d\u6570\uff0c\u4e00\u822c\u548c<code>std::fixed</code>\u7ed3\u5408\u8d77\u6765\u7528\u3002</p> <p>\u793a\u4f8b\u7a0b\u5e8f\uff1a <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\nusing namespace std;\nint main() {\n    double num = 1145141919810;\n    cout &lt;&lt; num &lt;&lt; endl;\n    cout &lt;&lt; fixed &lt;&lt; num &lt;&lt; endl;\n    cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; num &lt;&lt; endl;\n    return 0;\n}\n</code></pre></p> <p>\u8f93\u51fa\u7ed3\u679c\uff1a <pre><code>1.14514e+12\n1145141919810.000000\n1145141919810.00\n</code></pre></p>"}]}